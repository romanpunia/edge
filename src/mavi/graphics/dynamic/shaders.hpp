#ifndef HAS_SHADER_BATCH
#define HAS_SHADER_BATCH

namespace shader_batch
{
	void foreach(void* context, void(*callback)(void*, const char*, const unsigned char*, unsigned))
	{
		if (!callback)
			return;

		const unsigned char geometry_basic_geometry_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/immediate.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), ob_Transform);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat4 Color = GetDiffuse(V.TexCoord.xy);\nreturn float4(Color.xyz * ob_TexCoord.xyz, Color.w);\n};";
		callback(context, "geometry/basic/geometry.hlsl", geometry_basic_geometry_hlsl, sizeof(geometry_basic_geometry_hlsl));

		const unsigned char geometry_decal_geometry_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/geometry.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\n#include \"std/core/position.hlsl\"\nTexture2D LDepthBuffer : register(t8);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), ob_Transform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nfloat Depth = LDepthBuffer.SampleLevel(Sampler, TexCoord, 0).x;\n[branch] if (Depth >= 1.0)\ndiscard;\nfloat4 Position = mul(float4(TexCoord.x * 2.0 - 1.0, 1.0 - TexCoord.y * 2.0, Depth, 1.0), ob_World);\nclip(0.5 - abs(Position.xyz));\nfloat4 Color = float4(Materials[ob_MaterialId].Diffuse, 1.0);\n[branch] if (ob_Diffuse > 0)\n{\nColor *= GetDiffuse(TexCoord * ob_TexCoord.xy);\nif (Color.w < 0.001)\ndiscard;\n}\nreturn Color;\n};";
		callback(context, "geometry/decal/geometry.hlsl", geometry_decal_geometry_hlsl, sizeof(geometry_decal_geometry_hlsl));

		const unsigned char geometry_emitter_depth_linear_hlsl[] = "#include \"std/layouts/element.hlsl\"\n#include \"std/channels/stream.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutputLinear Make(VOutputLinear V, float2 Offset, float2 Coord)\n{\nfloat Sin = sin(V.Rotation), Cos = cos(V.Rotation);\nV.Position.xy += float2(Offset.x * Cos - Offset.y * Sin, Offset.x * Sin + Offset.y * Cos);\nV.Position = mul(V.Position, ob_World);\nV.TexCoord = Coord;\nV.UV = V.Position;\nreturn V;\n}\n[maxvertexcount(4)]\nvoid gs_main(point VOutputLinear V[1], inout TriangleStream<VOutputLinear> Stream)\n{\nVOutputLinear Next = V[0];\nStream.Append(Make(Next, float2(-1, -1) * Next.Scale, float2(0, 0)));\nStream.Append(Make(Next, float2(-1, 1) * Next.Scale, float2(0, -1)));\nStream.Append(Make(Next, float2(1, -1) * Next.Scale, float2(1, 0)));\nStream.Append(Make(Next, float2(1, 1) * Next.Scale, float2(1, -1)));\nStream.RestartStrip();\n}\nVOutputLinear vs_main(VInput V)\n{\nElement Base = Elements[V.Position];\nVOutputLinear Result = (VOutputLinear)0;\nResult.Position = mul(float4(Base.Position, 1), ob_Transform);\nResult.Rotation = Base.Rotation;\nResult.Scale = Base.Scale;\nResult.Alpha = Base.Color.w;\nResult.UV = Result.Position;\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (1.0 - V.Alpha) * (ob_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[ob_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn V.UV.z / V.UV.w;\n};";
		callback(context, "geometry/emitter/depth-linear.hlsl", geometry_emitter_depth_linear_hlsl, sizeof(geometry_emitter_depth_linear_hlsl));

		const unsigned char geometry_emitter_depth_point_hlsl[] = "#include \"std/layouts/element.hlsl\"\n#include \"std/channels/stream.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nmatrix FaceView[6];\n};\nVOutputCubic Make(VOutputLinear V, uint Face)\n{\nV.Position = mul(V.Position, FaceView[Face]);\nV.Position = mul(V.Position, vb_Proj);\nVOutputCubic Result = (VOutputCubic)0;\nResult.Position = V.Position;\nResult.UV = V.UV;\nResult.Alpha = V.Alpha;\nResult.RenderTarget = Face;\nreturn Result;\n}\n[maxvertexcount(6)]\nvoid gs_main(point VOutputLinear V[1], inout PointStream<VOutputCubic> Stream)\n{\nVOutputLinear Next = V[0];\n[unroll] for (uint Face = 0; Face < 6; Face++)\n{\nStream.Append(Make(Next, Face));\nStream.RestartStrip();\n}\n}\nVOutputLinear vs_main(VInput V)\n{\nElement Base = Elements[V.Position];\nVOutputLinear Result = (VOutputLinear)0;\nResult.Position = Result.UV = mul(float4(Base.Position, 1), ob_World);\nResult.Alpha = Base.Color.w;\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (1.0 - V.Alpha) * (ob_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[ob_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn length(V.UV.xyz - vb_Position) / vb_Far;\n};";
		callback(context, "geometry/emitter/depth-point.hlsl", geometry_emitter_depth_point_hlsl, sizeof(geometry_emitter_depth_point_hlsl));

		const unsigned char geometry_emitter_depth_quad_hlsl[] = "#include \"std/layouts/element.hlsl\"\n#include \"std/channels/stream.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nmatrix FaceView[6];\n};\nVOutputCubic Make(VOutputLinear V, float2 Offset, float2 Coord, uint Face)\n{\nfloat Sin = sin(V.Rotation), Cos = cos(V.Rotation);\nV.Position = mul(V.Position, FaceView[Face]);\nV.Position += float4(Offset.x * Cos - Offset.y * Sin, Offset.x * Sin + Offset.y * Cos, 0, 0);\nV.Position = mul(V.Position, vb_Proj);\nVOutputCubic Result = (VOutputCubic)0;\nResult.Position = V.Position;\nResult.UV = V.UV;\nResult.Rotation = V.Rotation;\nResult.Scale = V.Scale;\nResult.Alpha = V.Alpha;\nResult.RenderTarget = Face;\nResult.TexCoord = Coord;\nreturn Result;\n}\n[maxvertexcount(24)]\nvoid gs_main(point VOutputLinear V[1], inout TriangleStream<VOutputCubic> Stream)\n{\nVOutputLinear Next = V[0];\n[unroll] for (uint Face = 0; Face < 6; Face++)\n{\nStream.Append(Make(Next, float2(-1, -1) * Next.Scale, float2(0, 0), Face));\nStream.Append(Make(Next, float2(-1, 1) * Next.Scale, float2(0, -1), Face));\nStream.Append(Make(Next, float2(1, -1) * Next.Scale, float2(1, 0), Face));\nStream.Append(Make(Next, float2(1, 1) * Next.Scale, float2(1, -1), Face));\nStream.RestartStrip();\n}\n}\nVOutputLinear vs_main(VInput V)\n{\nElement Base = Elements[V.Position];\nVOutputLinear Result = (VOutputLinear)0;\nResult.Position = Result.UV = mul(float4(Base.Position, 1), ob_World);\nResult.Rotation = Base.Rotation;\nResult.Scale = Base.Scale;\nResult.Alpha = Base.Color.w;\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (1.0 - V.Alpha) * (ob_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[ob_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn length(V.UV.xyz - vb_Position) / vb_Far;\n};";
		callback(context, "geometry/emitter/depth-quad.hlsl", geometry_emitter_depth_quad_hlsl, sizeof(geometry_emitter_depth_quad_hlsl));

		const unsigned char geometry_emitter_opaque_hlsl[] = "#include \"std/layouts/element.hlsl\"\n#include \"std/channels/stream.hlsl\"\n#include \"std/channels/gbuffer.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutputOpaque Make(VOutputOpaque V, float2 Offset, float2 Coord)\n{\nfloat Sin = sin(V.Rotation), Cos = cos(V.Rotation);\nV.Position.xy += float2(Offset.x * Cos - Offset.y * Sin, Offset.x * Sin + Offset.y * Cos);\nV.Position = mul(V.Position, ob_World);\nV.TexCoord = Coord;\nV.UV = V.Position;\nreturn V;\n}\n[maxvertexcount(4)]\nvoid gs_main(point VOutputOpaque V[1], inout TriangleStream<VOutputOpaque> Stream)\n{\nVOutputOpaque Next = V[0];\nStream.Append(Make(Next, float2(-1, -1) * Next.Scale, float2(0, 0)));\nStream.Append(Make(Next, float2(-1, 1) * Next.Scale, float2(0, -1)));\nStream.Append(Make(Next, float2(1, -1) * Next.Scale, float2(1, 0)));\nStream.Append(Make(Next, float2(1, 1) * Next.Scale, float2(1, -1)));\nStream.RestartStrip();\n}\nVOutputOpaque vs_main(VInput V)\n{\nElement Base = Elements[V.Position];\nVOutputOpaque Result = (VOutputOpaque)0;\nResult.Position = mul(float4(Base.Position, 1), ob_Transform);\nResult.Rotation = Base.Rotation;\nResult.Color = Base.Color;\nResult.Scale = Base.Scale;\nResult.Normal = ob_TexCoord.xyz;\nResult.Tangent = float3(1, 0, 0);\nResult.Bitangent = float3(0, -1, 0);\nResult.UV = Result.Position;\nreturn Result;\n}\nGBuffer ps_main(VOutputOpaque V)\n{\nfloat4 Color = float4(Materials[ob_MaterialId].Diffuse * V.Color.xyz, V.Color.w);\n[branch] if (ob_Diffuse > 0)\n{\nColor *= GetDiffuse(V.TexCoord);\nif (Color.w < 0.001)\ndiscard;\n}\nfloat3 Normal = V.Normal;\n[branch] if (ob_Normal > 0)\nNormal = GetNormal(V.TexCoord, V.Normal, V.Tangent, V.Bitangent);\nreturn Compose(V.TexCoord, Color, Normal, V.UV.z / V.UV.w, ob_MaterialId);\n};";
		callback(context, "geometry/emitter/opaque.hlsl", geometry_emitter_opaque_hlsl, sizeof(geometry_emitter_opaque_hlsl));

		const unsigned char geometry_emitter_transparency_hlsl[] = "#include \"std/layouts/element.hlsl\"\n#include \"std/channels/stream.hlsl\"\n#include \"std/channels/gbuffer.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutput Make(VOutput V, float2 Offset, float2 Coord)\n{\nfloat Sin = sin(V.Rotation), Cos = cos(V.Rotation);\nV.Position.xy += float2(Offset.x * Cos - Offset.y * Sin, Offset.x * Sin + Offset.y * Cos);\nV.Position = mul(V.Position, ob_World);\nV.TexCoord = Coord;\nreturn V;\n}\n[maxvertexcount(4)]\nvoid gs_main(point VOutput V[1], inout TriangleStream<VOutput> Stream)\n{\nVOutput Next = V[0];\nStream.Append(Make(Next, float2(-1, -1) * Next.Scale, float2(0, 0)));\nStream.Append(Make(Next, float2(-1, 1) * Next.Scale, float2(0, -1)));\nStream.Append(Make(Next, float2(1, -1) * Next.Scale, float2(1, 0)));\nStream.Append(Make(Next, float2(1, 1) * Next.Scale, float2(1, -1)));\nStream.RestartStrip();\n}\nVOutput vs_main(VInput V)\n{\nElement Base = Elements[V.Position];\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(Base.Position, 1), ob_Transform);\nResult.Rotation = Base.Rotation;\nResult.Color = Base.Color;\nResult.Scale = Base.Scale;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat4 Color = float4(Materials[ob_MaterialId].Diffuse * V.Color.xyz, V.Color.w);\n[branch] if (ob_Diffuse > 0)\n{\nColor *= GetDiffuse(V.TexCoord);\nif (Color.w < 0.001)\ndiscard;\n}\nreturn Color;\n};";
		callback(context, "geometry/emitter/transparency.hlsl", geometry_emitter_transparency_hlsl, sizeof(geometry_emitter_transparency_hlsl));

		const unsigned char geometry_model_depth_cubic_hlsl[] = "#include \"std/layouts/vertex-instance.hlsl\"\n#include \"std/channels/depth.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/cubic.hlsl\"\n[maxvertexcount(18)]\nvoid gs_main(triangle VOutputLinear V[3], inout TriangleStream<VOutputCubic> Stream)\n{\n[unroll] for (uint Face = 0; Face < 6; Face++)\n{\nVOutputCubic Result = (VOutputCubic)0;\nResult.RenderTarget = Face;\n[unroll] for (uint Vertex = 0; Vertex < 3; Vertex++)\n{\nVOutputLinear Next = V[Vertex];\nResult.Position = mul(Next.Position, cb_ViewProjection[Face]);\nResult.UV = Next.UV;\nResult.TexCoord = Next.TexCoord;\nStream.Append(Result);\n}\nStream.RestartStrip();\n}\n}\nVOutputLinear vs_main(VInput V)\n{\nVOutputLinear Result = (VOutputLinear)0;\nResult.Position = Result.UV = mul(float4(V.Position, 1.0), V.OB_World);\nResult.TexCoord = V.TexCoord * V.OB_TexCoord.xy;\n Result.OB_Diffuse = V.OB_Material.x;\n Result.OB_MaterialId = V.OB_Material.w;\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (V.OB_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[V.OB_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn length(V.UV.xyz - vb_Position) / vb_Far;\n};";
		callback(context, "geometry/model/depth-cubic.hlsl", geometry_model_depth_cubic_hlsl, sizeof(geometry_model_depth_cubic_hlsl));

		const unsigned char geometry_model_depth_linear_hlsl[] = "#include \"std/layouts/vertex-instance.hlsl\"\n#include \"std/channels/depth.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutputLinear vs_main(VInput V)\n{\nVOutputLinear Result = (VOutputLinear)0;\nResult.Position = Result.UV = mul(float4(V.Position, 1.0), V.OB_Transform);\nResult.TexCoord = V.TexCoord * V.OB_TexCoord.xy;\n Result.OB_Diffuse = V.OB_Material.x;\n Result.OB_MaterialId = V.OB_Material.w;\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (V.OB_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[V.OB_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn V.UV.z / V.UV.w;\n};";
		callback(context, "geometry/model/depth-linear.hlsl", geometry_model_depth_linear_hlsl, sizeof(geometry_model_depth_linear_hlsl));

		const unsigned char geometry_model_geometry_hlsl[] = "#include \"std/layouts/vertex-instance.hlsl\"\n#include \"std/channels/gbuffer.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = Result.UV = mul(float4(V.Position, 1.0), V.OB_Transform);\nResult.Normal = normalize(mul(V.Normal, (float3x3)V.OB_World));\nResult.Tangent = normalize(mul(V.Tangent, (float3x3)V.OB_World));\nResult.Bitangent = normalize(mul(V.Bitangent, (float3x3)V.OB_World));\nResult.TexCoord = V.TexCoord * V.OB_TexCoord;\n Result.OB_Diffuse = V.OB_Material.x;\n Result.OB_Normal = V.OB_Material.y;\n Result.OB_Height = V.OB_Material.z;\n Result.OB_MaterialId = V.OB_Material.w;\n \n[branch] if (Result.OB_Height > 0)\nResult.Direction = GetDirection(Result.Tangent, Result.Bitangent, Result.Normal, mul(float4(V.Position, 1.0), ob_World), ob_TexCoord.xy);\nreturn Result;\n}\nGBuffer ps_main(VOutput V)\n{\nMaterial Mat = Materials[V.OB_MaterialId];\nfloat2 Coord = V.TexCoord;\n[branch] if (V.OB_Height > 0)\nCoord = GetParallax(Coord, V.Direction, Mat.Height, Mat.Bias);\nfloat4 Color = float4(Mat.Diffuse, 1.0);\n[branch] if (V.OB_Diffuse > 0)\n{\nColor *= GetDiffuse(Coord);\nif (Color.w < 0.001)\ndiscard;\n}\nfloat3 Normal = V.Normal;\n[branch] if (V.OB_Normal > 0)\nNormal = GetNormal(Coord, V.Normal, V.Tangent, V.Bitangent);\nreturn Compose(Coord, Color, Normal, V.UV.z / V.UV.w, V.OB_MaterialId);\n};";
		callback(context, "geometry/model/geometry.hlsl", geometry_model_geometry_hlsl, sizeof(geometry_model_geometry_hlsl));

		const unsigned char geometry_model_occlusion_hlsl[] = "#include \"std/layouts/vertex.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), ob_Transform);\nreturn Result;\n}";
		callback(context, "geometry/model/occlusion.hlsl", geometry_model_occlusion_hlsl, sizeof(geometry_model_occlusion_hlsl));

		const unsigned char geometry_model_voxelize_hlsl[] = "#include \"std/layouts/vertex-instance.hlsl\"\n#include \"std/channels/gvoxelizer.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = Result.UV = GetVoxel(mul(float4(V.Position, 1.0), V.OB_World));\nResult.Normal = normalize(mul(V.Normal, (float3x3)V.OB_World));\nResult.Tangent = normalize(mul(V.Tangent, (float3x3)V.OB_World));\nResult.Bitangent = normalize(mul(V.Bitangent, (float3x3)V.OB_World));\nResult.TexCoord = V.TexCoord * V.OB_TexCoord.xy;\n Result.OB_Diffuse = V.OB_Material.x;\n Result.OB_Normal = V.OB_Material.y;\n Result.OB_MaterialId = V.OB_Material.w;\nreturn Result;\n}\nfloat GetAvg(float3 Value)\n{\nreturn (Value.x + Value.y + Value.z) / 3.0;\n}\n[maxvertexcount(3)]\nvoid gs_main(triangle VOutput V[3], inout TriangleStream<VOutput> Stream)\n{\n uint Dominant = GetVoxelDominant(V[0].Position.xyz, V[1].Position.xyz, V[2].Position.xyz); \n[unroll] for (uint i = 0; i < 3; ++i)\n{\nVOutput Next = V[i];\nNext.Position = GetVoxelPosition(Next.Position, Dominant);\nStream.Append(Next);\n}\n Stream.RestartStrip();\n}\nvoid ps_main(VOutput V)\n{\nfloat4 Color = float4(Materials[V.OB_MaterialId].Diffuse, 1.0);\n[branch] if (V.OB_Diffuse > 0)\n{\nColor *= GetDiffuse(V.TexCoord);\nif (Color.w < 0.001)\ndiscard;\n}\nfloat3 Normal = V.Normal;\n[branch] if (V.OB_Normal > 0)\nNormal = GetNormal(V.TexCoord, V.Normal, V.Tangent, V.Bitangent);\nCompose(V.TexCoord, Color, Normal, V.UV.xyz, V.OB_MaterialId);\n};";
		callback(context, "geometry/model/voxelize.hlsl", geometry_model_voxelize_hlsl, sizeof(geometry_model_voxelize_hlsl));

		const unsigned char geometry_skin_depth_cubic_hlsl[] = "#include \"std/layouts/skin.hlsl\"\n#include \"std/channels/depth.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/cubic.hlsl\"\n#include \"std/buffers/animation.hlsl\"\n[maxvertexcount(18)]\nvoid gs_main(triangle VOutputLinear V[3], inout TriangleStream<VOutputCubic> Stream)\n{\n[unroll] for (uint Face = 0; Face < 6; Face++)\n{\nVOutputCubic Result = (VOutputCubic)0;\nResult.RenderTarget = Face;\n[unroll] for (uint Vertex = 0; Vertex < 3; Vertex++)\n{\nVOutputLinear Next = V[Vertex];\nResult.Position = Result.UV = mul(Next.Position, cb_ViewProjection[Face]);\nResult.UV = Next.UV;\nResult.TexCoord = Next.TexCoord;\nStream.Append(Result);\n}\nStream.RestartStrip();\n}\n}\nVOutputLinear vs_main(VInput V)\n{\nVOutputLinear Result = (VOutputLinear)0;\nResult.TexCoord = V.TexCoord * ob_TexCoord.xy;\n[branch] if (ab_Animated > 0)\n{\nmatrix Offset =\nmul(ab_Offsets[(int)V.Index.x], V.Bias.x) +\nmul(ab_Offsets[(int)V.Index.y], V.Bias.y) +\nmul(ab_Offsets[(int)V.Index.z], V.Bias.z) +\nmul(ab_Offsets[(int)V.Index.w], V.Bias.w);\nResult.Position = Result.UV = mul(mul(float4(V.Position, 1.0), Offset), ob_World);\n}\nelse\nResult.Position = Result.UV = mul(float4(V.Position, 1.0), ob_World);\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (ob_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[ob_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn length(V.UV.xyz - vb_Position) / vb_Far;\n};";
		callback(context, "geometry/skin/depth-cubic.hlsl", geometry_skin_depth_cubic_hlsl, sizeof(geometry_skin_depth_cubic_hlsl));

		const unsigned char geometry_skin_depth_linear_hlsl[] = "#include \"std/layouts/skin.hlsl\"\n#include \"std/channels/depth.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/animation.hlsl\"\nVOutputLinear vs_main(VInput V)\n{\nVOutputLinear Result = (VOutputLinear)0;\nResult.TexCoord = V.TexCoord * ob_TexCoord.xy;\n[branch] if (ab_Animated > 0)\n{\nmatrix Offset =\nmul(ab_Offsets[(int)V.Index.x], V.Bias.x) +\nmul(ab_Offsets[(int)V.Index.y], V.Bias.y) +\nmul(ab_Offsets[(int)V.Index.z], V.Bias.z) +\nmul(ab_Offsets[(int)V.Index.w], V.Bias.w);\nResult.Position = Result.UV = mul(mul(float4(V.Position, 1.0), Offset), ob_Transform);\n}\nelse\nResult.Position = Result.UV = mul(float4(V.Position, 1.0), ob_Transform);\nreturn Result;\n}\nfloat ps_main(VOutputLinear V) : SV_DEPTH\n{\nfloat Threshold = (ob_Diffuse ? 1.0 - GetDiffuse(V.TexCoord).w : 1.0) * Materials[ob_MaterialId].Transparency;\n[branch] if (Threshold > 0.5)\ndiscard;\nreturn V.UV.z / V.UV.w;\n};";
		callback(context, "geometry/skin/depth-linear.hlsl", geometry_skin_depth_linear_hlsl, sizeof(geometry_skin_depth_linear_hlsl));

		const unsigned char geometry_skin_geometry_hlsl[] = "#include \"std/layouts/skin.hlsl\"\n#include \"std/channels/gbuffer.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/animation.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.TexCoord = V.TexCoord * ob_TexCoord.xy;\nfloat4 Position = float4(V.Position, 1.0);\n[branch] if (ab_Animated > 0)\n{\nmatrix Offset =\nmul(ab_Offsets[(int)V.Index.x], V.Bias.x) +\nmul(ab_Offsets[(int)V.Index.y], V.Bias.y) +\nmul(ab_Offsets[(int)V.Index.z], V.Bias.z) +\nmul(ab_Offsets[(int)V.Index.w], V.Bias.w);\nPosition = mul(float4(V.Position, 1.0), Offset);\nResult.Position = Result.UV = mul(Position, ob_Transform);\nResult.Normal = normalize(mul(mul(float4(V.Normal, 0), Offset).xyz, (float3x3)ob_World));\nResult.Tangent = normalize(mul(mul(float4(V.Tangent, 0), Offset).xyz, (float3x3)ob_World));\nResult.Bitangent = normalize(mul(mul(float4(V.Bitangent, 0), Offset).xyz, (float3x3)ob_World)); \n}\nelse\n{\nResult.Position = Result.UV = mul(Position, ob_Transform);\nResult.Normal = normalize(mul(V.Normal, (float3x3)ob_World));\nResult.Tangent = normalize(mul(V.Tangent, (float3x3)ob_World));\nResult.Bitangent = normalize(mul(V.Bitangent, (float3x3)ob_World));\n}\n[branch] if (ob_Height > 0)\nResult.Direction = GetDirection(Result.Tangent, Result.Bitangent, Result.Normal, mul(Position, ob_World), ob_TexCoord.xy);\nreturn Result;\n}\nGBuffer ps_main(VOutput V)\n{\nMaterial Mat = Materials[ob_MaterialId];\nfloat2 Coord = V.TexCoord;\n[branch] if (ob_Height > 0)\nCoord = GetParallax(Coord, V.Direction, Mat.Height, Mat.Bias);\nfloat4 Color = float4(Mat.Diffuse, 1.0);\n[branch] if (ob_Diffuse > 0)\n{\nColor *= GetDiffuse(Coord);\nif (Color.w < 0.001)\ndiscard;\n}\nfloat3 Normal = V.Normal;\n[branch] if (ob_Normal > 0)\nNormal = GetNormal(Coord, V.Normal, V.Tangent, V.Bitangent);\nreturn Compose(Coord, Color, Normal, V.UV.z / V.UV.w, ob_MaterialId);\n};";
		callback(context, "geometry/skin/geometry.hlsl", geometry_skin_geometry_hlsl, sizeof(geometry_skin_geometry_hlsl));

		const unsigned char geometry_skin_occlusion_hlsl[] = "#include \"std/layouts/skin.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/animation.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\n[branch] if (ab_Animated > 0)\n{\nmatrix Offset =\nmul(ab_Offsets[(int)V.Index.x], V.Bias.x) +\nmul(ab_Offsets[(int)V.Index.y], V.Bias.y) +\nmul(ab_Offsets[(int)V.Index.z], V.Bias.z) +\nmul(ab_Offsets[(int)V.Index.w], V.Bias.w);\nResult.Position = mul(mul(float4(V.Position, 1.0), Offset), ob_Transform);\n}\nelse\nResult.Position = mul(float4(V.Position, 1.0), ob_Transform);\nreturn Result;\n}";
		callback(context, "geometry/skin/occlusion.hlsl", geometry_skin_occlusion_hlsl, sizeof(geometry_skin_occlusion_hlsl));

		const unsigned char geometry_skin_voxelize_hlsl[] = "#include \"std/layouts/skin.hlsl\"\n#include \"std/channels/gvoxelizer.hlsl\"\n#include \"std/buffers/object.hlsl\"\n#include \"std/buffers/animation.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.TexCoord = V.TexCoord * ob_TexCoord.xy;\nfloat4 Position = float4(V.Position, 1.0);\n[branch] if (ab_Animated > 0)\n{\nmatrix Offset =\nmul(ab_Offsets[(int)V.Index.x], V.Bias.x) +\nmul(ab_Offsets[(int)V.Index.y], V.Bias.y) +\nmul(ab_Offsets[(int)V.Index.z], V.Bias.z) +\nmul(ab_Offsets[(int)V.Index.w], V.Bias.w);\nPosition = mul(float4(V.Position, 1.0), Offset);\nResult.Position = Result.UV = GetVoxel(mul(Position, ob_World));\nResult.Normal = normalize(mul(mul(float4(V.Normal, 0), Offset).xyz, (float3x3)ob_World));\nResult.Tangent = normalize(mul(mul(float4(V.Tangent, 0), Offset).xyz, (float3x3)ob_World));\nResult.Bitangent = normalize(mul(mul(float4(V.Bitangent, 0), Offset).xyz, (float3x3)ob_World)); \n}\nelse\n{\nResult.Position = Result.UV = GetVoxel(mul(Position, ob_World));\nResult.Normal = normalize(mul(V.Normal, (float3x3)ob_World));\nResult.Tangent = normalize(mul(V.Tangent, (float3x3)ob_World));\nResult.Bitangent = normalize(mul(V.Bitangent, (float3x3)ob_World));\n}\nreturn Result;\n}\n[maxvertexcount(3)]\nvoid gs_main(triangle VOutput V[3], inout TriangleStream<VOutput> Stream)\n{\nuint Dominant = GetVoxelDominant(V[0].Position.xyz, V[1].Position.xyz, V[2].Position.xyz); \n[unroll] for (uint i = 0; i < 3; ++i)\n{\nVOutput Next = V[i];\nNext.Position = GetVoxelPosition(Next.Position, Dominant);\nStream.Append(Next);\n}\n Stream.RestartStrip();\n}\nvoid ps_main(VOutput V)\n{\nfloat4 Color = float4(Materials[ob_MaterialId].Diffuse, 1.0);\n[branch] if (ob_Diffuse > 0)\n{\nColor *= GetDiffuse(V.TexCoord);\nif (Color.w < 0.001)\ndiscard;\n}\nfloat3 Normal = V.Normal;\n[branch] if (ob_Normal > 0)\nNormal = GetNormal(V.TexCoord, V.Normal, V.Tangent, V.Bitangent);\nCompose(V.TexCoord, Color, Normal, V.UV.xyz, ob_MaterialId);\n};";
		callback(context, "geometry/skin/voxelize.hlsl", geometry_skin_voxelize_hlsl, sizeof(geometry_skin_voxelize_hlsl));

		const unsigned char interface_box_blur_hlsl[] = "#include \"std/layouts/interface.hlsl\"\n#include \"std/channels/immediate.hlsl\"\n#include \"std/buffers/object.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat4 Color;\nfloat4 Radius;\nfloat2 Texel;\nfloat2 Size;\nfloat2 Position;\nfloat Softness;\nfloat Alpha;\n}\nfloat Rectangle(float2 Position, float2 Size, float4 Radius)\n{\nfloat2 T = step(Position, float2(0.0, 0.0));\nfloat R = lerp(lerp(Radius.y, Radius.z, T.y), lerp(Radius.x, Radius.w, T.y), T.x);\nreturn length(max(abs(Position) + float2(R, R) - Size, 0.0)) - R;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result;\nResult.Position = mul(float4(V.Position.xy, 0.0, 1.0), ob_Transform);\nResult.UV = mul(Result.Position, ob_World);\nResult.Color = float4(0.0, 0.0, 0.0, 0.0);\nResult.TexCoord = V.TexCoord;\nreturn Result;\n};\nfloat4 ps_main(VOutput V) : SV_Target\n{\nfloat Distance = Rectangle(V.UV.xy - Size / 2.0, Size / 2.0 - 1, Radius);\n[branch] if (saturate(1.0 - smoothstep(0.0, 2.0, Distance)) < 0.25)\nreturn float4(0, 0, 0, 0);\nconst float Directions = 16.0;\nconst float Quality = 3.0;\nfloat2 Cover = Softness;\nfloat3 Result = DiffuseMap.Load(int3(V.Position.xy, 0)).xyz;\n[unroll] for (float d = 0.0; d < 6.283185; d += 6.283185 / Directions)\n{\n[unroll] for (float i = 1.0 / Quality; i <= 1.0; i += 1.0 / Quality)\nResult += DiffuseMap.Load(int3(V.Position.xy + float2(cos(d), sin(d)) * Cover * i, 0)).xyz;\n}\nResult /= Quality * Directions;\nreturn float4(Result * Color.xyz, Color.w * Alpha);\n};";
		callback(context, "interface/box-blur.hlsl", interface_box_blur_hlsl, sizeof(interface_box_blur_hlsl));

		const unsigned char interface_box_shadow_hlsl[] = "#include \"std/layouts/interface.hlsl\"\n#include \"std/channels/immediate.hlsl\"\n#include \"std/buffers/object.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat4 Color;\nfloat4 Radius;\nfloat2 Size;\nfloat2 Position;\nfloat2 Offset;\nfloat Softness;\nfloat Padding;\n}\nfloat Rectangle(float2 Position, float2 Size, float4 Radius)\n{\nfloat2 T = step(Position, float2(0.0, 0.0));\nfloat R = lerp(lerp(Radius.y, Radius.z, T.y), lerp(Radius.x, Radius.w, T.y), T.x);\nreturn length(max(abs(Position) + float2(R, R) - Size, 0.0)) - R;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result;\nResult.Position = mul(float4(V.Position.xy, 0.0, 1.0), ob_Transform);\nResult.UV = mul(Result.Position, ob_World);\nResult.Color = float4(0.0, 0.0, 0.0, 0.0);\nResult.TexCoord = float2(0.0, 0.0);\nreturn Result;\n};\nfloat4 ps_main(VOutput V) : SV_Target\n{\nfloat2 Center = V.UV.xy - Size / 2.0;\nfloat Distance1 = Rectangle(Center, Size / 2.0 - 1, Radius);\nfloat Alpha1 = saturate(1.0 - smoothstep(0.0, 2.0, Distance1)); \nfloat Distance2 = Rectangle(Center + Offset, Size / 2.0, Radius);\nfloat Alpha2 = saturate(1.0 - smoothstep(-Softness, Softness, Distance2));\nfloat4 Result = lerp(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0) - Alpha1, Alpha1);\nreturn lerp(Result, Color, Alpha2 - Alpha1);\n};";
		callback(context, "interface/box-shadow.hlsl", interface_box_shadow_hlsl, sizeof(interface_box_shadow_hlsl));

		const unsigned char interface_geometry_hlsl[] = "#include \"std/layouts/interface.hlsl\"\n#include \"std/channels/immediate.hlsl\"\n#include \"std/buffers/object.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result;\nResult.Position = mul(float4(V.Position.xy, 0.0, 1.0), ob_Transform);\nResult.Color = V.Color;\nResult.TexCoord = V.TexCoord;\nResult.UV = Result.Position;\nreturn Result;\n};\nfloat4 ps_main(VOutput V) : SV_Target\n{\nfloat4 Color = V.Color;\n[branch] if (ob_Diffuse > 0)\nColor *= GetDiffuse(V.TexCoord);\nreturn Color;\n};";
		callback(context, "interface/geometry.hlsl", interface_geometry_hlsl, sizeof(interface_geometry_hlsl));

		const unsigned char lighting_ambient_direct_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nmatrix SkyOffset;\nfloat3 HighEmission;\nfloat SkyEmission;\nfloat3 LowEmission;\nfloat LightEmission;\nfloat3 SkyColor;\nfloat FogFarOff;\nfloat3 FogColor;\nfloat FogNearOff;\nfloat3 FogFar;\nfloat FogAmount;\nfloat3 FogNear;\nfloat Recursive;\n};\nstruct AmbientVertexResult\n{\nfloat4 Position : SV_POSITION;\nfloat4 TexCoord : TEXCOORD0;\nfloat4 View : TEXCOORD1;\n};\nTexture2D LightMap : register(t5);\nTextureCube SkyMap : register(t6);\nfloat3 GetScattering(float3 Color, float Distance)\n{\nfloat3 Far = float3(exp(-Distance * FogFar.x), exp(-Distance * FogFar.y), exp(-Distance * FogFar.z));\nfloat3 Near = float3(exp(-Distance * FogNear.x), exp(-Distance * FogNear.y), exp(-Distance * FogNear.z));\nfloat3 Result = FogColor * (1.0 - max(FogFarOff, Far)) + Color * max(FogNearOff, Near);\nreturn lerp(Color, Result, FogAmount);\n}\nfloat3 GetIllumination(float3 Up, float3 Down, float Height)\n{\nreturn (Height * 0.5 + 0.5) * Up + Down;\n}\nAmbientVertexResult vs_main(VInput V)\n{\nAmbientVertexResult Result = (AmbientVertexResult)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nResult.View = mul(float4(V.Position.xy, 1.0, 1.0), SkyOffset);\nResult.View.xyz /= Result.View.w;\nreturn Result;\n}\nfloat4 ps_main(AmbientVertexResult V) : SV_TARGET0\n{\nFragment Frag = GetFragment(V.TexCoord.xy);\nfloat4 R = LightMap.Sample(Sampler, V.TexCoord.xy) * LightEmission;\nfloat L = distance(Frag.Position, vb_Position);\n[branch] if (Frag.Depth >= 1.0)\n{\nR.xyz = Frag.Diffuse + R.xyz * SkyColor * (1.0 - SkyEmission) + SkyMap.Sample(Sampler, V.View.xyz).xyz * SkyEmission;\nreturn float4(GetScattering(R.xyz, L), 1.0);\n}\nMaterial Mat = Materials[Frag.Material];\nfloat3 E = GetEmission(Frag, Mat);\nfloat3 O = GetOcclusion(Frag, Mat);\nfloat3 M = GetBaseReflectivity(Frag.Diffuse, GetMetallic(Frag, Mat));\nfloat3 A = GetIllumination(HighEmission, LowEmission, Frag.Normal.y);\nfloat3 F = GetFresnelSchlick(dot(normalize(Frag.Position - vb_Position), Frag.Normal), M);\nfloat3 D = lerp(Frag.Diffuse.xyz, F, F * Mat.Fresnel * 0.05);\nR.xyz += A * D * O + GetIllumination(E, E * 0.5, Frag.Normal.y) * O;\nreturn float4(GetScattering(R.xyz, L), 1.0);\n};";
		callback(context, "lighting/ambient/direct.hlsl", lighting_ambient_direct_hlsl, sizeof(lighting_ambient_direct_hlsl));

		const unsigned char lighting_ambient_indirect_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/raytracer.hlsl\"\n#include \"std/core/raytracing.hlsl\"\n#include \"std/core/position.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), vxb_Transform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(Frag.Diffuse, 1.0);\nMaterial Mat = Materials[Frag.Material];\nfloat R = GetRoughness(Frag, Mat), Shadow;\nfloat L = distance(Frag.Position, -1.0) * vxb_Length;\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetEmission(Frag, Mat);\nfloat3 D = normalize(Frag.Position - vb_Position);\nfloat3 Radiance = GetRadiance(Frag.Position, Frag.Normal, M, Shadow);\nfloat3 Reflectance = GetSpecular(Frag.Position, Frag.Normal, D, L, M, R);\nfloat3 Result = (Frag.Diffuse + vxb_Radiance * (E + Radiance) + vxb_Specular * Reflectance) * (1.0 - Mat.Transparency);\n[branch] if (Mat.Transparency > 0)\n{\nfloat3 Refraction = GetRefraction(Frag.Position, Frag.Normal, D, L, M, R, Mat.Refraction, Mat.Transparency);\nResult += vxb_Specular * Refraction;\n}\nreturn float4(Result * Shadow, Shadow);\n};";
		callback(context, "lighting/ambient/indirect.hlsl", lighting_ambient_indirect_hlsl, sizeof(lighting_ambient_indirect_hlsl));

		const unsigned char lighting_line_common_array_hlsl[] = "struct LineLight\n{\nmatrix LightViewProjection[6];\nmatrix SkyOffset;\nfloat3 RlhEmission;\nfloat RlhHeight;\nfloat3 MieEmission;\nfloat MieHeight;\nfloat3 Lighting;\nfloat Softness;\nfloat3 Position;\nfloat Cascades;\nfloat2 Padding;\nfloat Bias;\nfloat Iterations;\nfloat ScatterIntensity;\nfloat PlanetRadius;\nfloat AtmosphereRadius;\nfloat MieDirection;\n};\nStructuredBuffer<LineLight> LineLights : register(t7);";
		callback(context, "lighting/line/common/array.hlsl", lighting_line_common_array_hlsl, sizeof(lighting_line_common_array_hlsl));

		const unsigned char lighting_line_common_buffer_hlsl[] = "cbuffer RenderConstant : register(b3)\n{\nmatrix LightViewProjection[6];\nmatrix SkyOffset;\nfloat3 RlhEmission;\nfloat RlhHeight;\nfloat3 MieEmission;\nfloat MieHeight;\nfloat3 Lighting;\nfloat Softness;\nfloat3 Position;\nfloat Cascades;\nfloat2 Padding;\nfloat Bias;\nfloat Iterations;\nfloat ScatterIntensity;\nfloat PlanetRadius;\nfloat AtmosphereRadius;\nfloat MieDirection;\n};";
		callback(context, "lighting/line/common/buffer.hlsl", lighting_line_common_buffer_hlsl, sizeof(lighting_line_common_buffer_hlsl));

		const unsigned char lighting_line_high_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/multisample.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/atmosphere.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"lighting/line/common/buffer.hlsl\"\n#pragma warning(disable: 3595)\nTexture2D DepthMap[6] : register(t5);\nSamplerComparisonState DepthLessSampler : register(s5);\nfloat GetLightness(uniform uint Index, float2 D, float L)\n{\nfloat Result = 0.0;\n[loop] for (float j = 0; j < Iterations; j++)\n{\nfloat2 Offset = SampleDisk[j % 64].xy * (j / 64.0) / Softness;\nResult += DepthMap[Index].SampleCmpLevelZero(DepthLessSampler, D + Offset, L);\n }\nreturn Result / Iterations;\n}\nfloat GetCascade(float3 Position, uniform uint Index)\n{\n[branch] if (Index >= (uint)Cascades)\nreturn 1.0;\nfloat4 L = mul(float4(Position, 1), LightViewProjection[Index]);\n#ifdef TARGET_D3D\nfloat2 T = float2(L.x / L.w / 2.0 + 0.5f, 1 - (L.y / L.w / 2.0 + 0.5f));\n#else\nfloat2 T = float2(L.x / L.w / 2.0 + 0.5f, L.y / L.w / 2.0 + 0.5f);\n#endif\n[branch] if (saturate(T.x) != T.x || saturate(T.y) != T.y)\nreturn -1.0;\nfloat D = L.z / L.w - Bias, C, B;\nreturn GetLightness(Index, T, D);\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nFragment Frag = GetFragment(TexCoord);\n[branch] if (Frag.Depth >= 1.0)\n{\n[branch] if (ScatterIntensity <= 0.0)\nreturn float4(0, 0, 0, 0);\nScatter A;\nA.Sun = ScatterIntensity;\nA.Planet = PlanetRadius;\nA.Atmos = AtmosphereRadius;\nA.Rlh = RlhEmission;\nA.Mie = MieEmission;\nA.RlhHeight = RlhHeight;\nA.MieHeight = MieHeight;\nA.MieG = MieDirection;\nreturn float4(GetAtmosphere(TexCoord, SkyOffset, float3(0, 6372e3, 0), float3(-Position.x, Position.y, Position.z), A), 1.0);\n}\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, Position, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, Position, Mat.Scatter) * E;\nR = Lighting * (R + S);\nfloat H = GetCascade(Frag.Position, 0);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nH = GetCascade(Frag.Position, 1);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nH = GetCascade(Frag.Position, 2);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nH = GetCascade(Frag.Position, 3);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nH = GetCascade(Frag.Position, 4);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nH = GetCascade(Frag.Position, 5);\n[branch] if (H >= 0.0)\nreturn float4(R * (H + S), 1.0);\nreturn float4(R, 1.0);\n};";
		callback(context, "lighting/line/high.hlsl", lighting_line_high_hlsl, sizeof(lighting_line_high_hlsl));

		const unsigned char lighting_line_low_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/atmosphere.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"lighting/line/common/buffer.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nFragment Frag = GetFragment(TexCoord);\n[branch] if (Frag.Depth >= 1.0)\n{\n[branch] if (ScatterIntensity <= 0.0)\nreturn float4(0, 0, 0, 0);\nScatter A;\nA.Sun = ScatterIntensity;\nA.Planet = PlanetRadius;\nA.Atmos = AtmosphereRadius;\nA.Rlh = RlhEmission;\nA.Mie = MieEmission;\nA.RlhHeight = RlhHeight;\nA.MieHeight = MieHeight;\nA.MieG = MieDirection;\nreturn float4(GetAtmosphere(TexCoord, SkyOffset, float3(0, 6372e3, 0), float3(-Position.x, Position.y, Position.z), A), 1.0);\n}\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, Position, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, Position, Mat.Scatter) * E;\nreturn float4(Lighting * (R + S), 1.0);\n};";
		callback(context, "lighting/line/low.hlsl", lighting_line_low_hlsl, sizeof(lighting_line_low_hlsl));

		const unsigned char lighting_point_common_array_hlsl[] = "struct PointLight\n{\nmatrix LightTransform;\nfloat4 Attenuation;\nfloat3 Position;\nfloat Range;\nfloat3 Lighting;\nfloat Distance;\nfloat Umbra;\nfloat Softness;\nfloat Bias;\nfloat Iterations;\n};\nStructuredBuffer<PointLight> PointLights : register(t5);";
		callback(context, "lighting/point/common/array.hlsl", lighting_point_common_array_hlsl, sizeof(lighting_point_common_array_hlsl));

		const unsigned char lighting_point_common_buffer_hlsl[] = "cbuffer RenderConstant : register(b3)\n{\nmatrix LightTransform;\nfloat4 Attenuation;\nfloat3 Position;\nfloat Range;\nfloat3 Lighting;\nfloat Distance;\nfloat Umbra;\nfloat Softness;\nfloat Bias;\nfloat Iterations;\n};";
		callback(context, "lighting/point/common/buffer.hlsl", lighting_point_common_buffer_hlsl, sizeof(lighting_point_common_buffer_hlsl));

		const unsigned char lighting_point_high_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"std/core/multisample.hlsl\"\n#include \"lighting/point/common/buffer.hlsl\"\n#pragma warning(disable: 4000)\nTextureCube DepthMap : register(t5);\nTextureCube DepthMapLess : register(t6);\nTextureCube DepthMapGreater : register(t7);\nSamplerState DepthSampler : register(s5);\nSamplerComparisonState DepthLessSampler : register(s6);\nSamplerComparisonState DepthGreaterSampler : register(s7);\nfloat GetPenumbra(float3 D, float L)\n{\n[branch] if (Umbra <= 0.0)\nreturn 0.0;\nfloat Length = 0.0;\n[unroll] for (float i = 0; i < 16; i++)\n{\nfloat3 TexCoord = D + SampleDisk[i] * (i / 64.0) / Softness;\nfloat S1 = DepthMap.SampleLevel(DepthSampler, TexCoord, 0).x;\nfloat S2 = DepthMapGreater.SampleCmpLevelZero(DepthGreaterSampler, TexCoord, L);\nLength += S1 * S2;\n}\nLength /= 16.0;\nreturn saturate(Umbra * (L - Length) / Length);\n}\nfloat GetLightness(float3 D, float L)\n{\nfloat Penumbra = GetPenumbra(D, L);\n[branch] if (Penumbra >= 1.0)\nreturn 1.0;\nfloat Result = 0.0;\n[loop] for (float j = 0; j < Iterations; j++)\n{\nfloat3 Offset = SampleDisk[j % 64] * (j / 64.0) / Softness;\nResult += DepthMapLess.SampleCmpLevelZero(DepthLessSampler, D + Offset, L);\n}\nreturn lerp(Result / Iterations, 1.0, Penumbra);\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), LightTransform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0, 0, 0, 0);\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 K = Position - Frag.Position;\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 L = normalize(K);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, L, Mat.Scatter) * E;\nfloat A = GetRangeAttenuation(K, Attenuation.x, Attenuation.y, Range);\n#ifndef TARGET_D3D\nL.y = -L.y;\n#endif\nA *= GetLightness(-L, length(K) / Distance - Bias) + length(S) / 3.0;\nreturn float4(Lighting * (R + S) * A, A);\n};";
		callback(context, "lighting/point/high.hlsl", lighting_point_high_hlsl, sizeof(lighting_point_high_hlsl));

		const unsigned char lighting_point_low_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"lighting/point/common/buffer.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), LightTransform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0, 0, 0, 0);\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 K = Position - Frag.Position;\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 L = normalize(K);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, L, Mat.Scatter) * E;\nfloat A = GetRangeAttenuation(K, Attenuation.x, Attenuation.y, Range);\nreturn float4(Lighting * (R + S) * A, A);\n};";
		callback(context, "lighting/point/low.hlsl", lighting_point_low_hlsl, sizeof(lighting_point_low_hlsl));

		const unsigned char lighting_spot_common_array_hlsl[] = "struct SpotLight\n{\nmatrix LightTransform;\nmatrix LightViewProjection;\nfloat4 Attenuation;\nfloat3 Direction;\nfloat Cutoff;\nfloat3 Position;\nfloat Range;\nfloat3 Lighting;\nfloat Softness;\nfloat Bias;\nfloat Iterations;\nfloat Umbra;\nfloat Padding;\n};\nStructuredBuffer<SpotLight> SpotLights : register(t6);";
		callback(context, "lighting/spot/common/array.hlsl", lighting_spot_common_array_hlsl, sizeof(lighting_spot_common_array_hlsl));

		const unsigned char lighting_spot_common_buffer_hlsl[] = "cbuffer RenderConstant : register(b3)\n{\nmatrix LightTransform;\nmatrix LightViewProjection;\nfloat4 Attenuation;\nfloat3 Direction;\nfloat Cutoff;\nfloat3 Position;\nfloat Range;\nfloat3 Lighting;\nfloat Softness;\nfloat Bias;\nfloat Iterations;\nfloat Umbra;\nfloat Padding;\n};";
		callback(context, "lighting/spot/common/buffer.hlsl", lighting_spot_common_buffer_hlsl, sizeof(lighting_spot_common_buffer_hlsl));

		const unsigned char lighting_spot_high_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/multisample.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"lighting/spot/common/buffer.hlsl\"\n#pragma warning(disable: 4000)\nTexture2D DepthMap : register(t5);\nTexture2D DepthMapLess : register(t6);\nTexture2D DepthMapGreater : register(t7);\nSamplerState DepthSampler : register(s5);\nSamplerComparisonState DepthLessSampler : register(s6);\nSamplerComparisonState DepthGreaterSampler : register(s7);\nfloat GetPenumbra(float2 D, float L)\n{\n[branch] if (Umbra <= 0.0)\nreturn 0.0;\nfloat Length = 0.0;\n[unroll] for (float i = 0; i < 16; i++)\n{\nfloat2 TexCoord = D + SampleDisk[i].xy * (i / 64.0) / Softness;\nfloat S1 = DepthMap.SampleLevel(DepthSampler, TexCoord, 0).x;\nfloat S2 = DepthMapGreater.SampleCmpLevelZero(DepthGreaterSampler, TexCoord, L);\nLength += S1 * S2;\n}\nLength /= 16.0;\nreturn saturate(Umbra * vb_Far * (L - Length) / Length);\n}\nfloat GetLightness(float2 D, float L)\n{\nfloat Penumbra = GetPenumbra(D, L);\n[branch] if (Penumbra >= 1.0)\nreturn 1.0;\nfloat Result = 0.0;\n[loop] for (float j = 0; j < Iterations; j++)\n{\nfloat2 Offset = SampleDisk[j % 64].xy * (j / 64.0) / Softness;\nResult += DepthMapLess.SampleCmpLevelZero(DepthLessSampler, D + Offset, L);\n}\nreturn lerp(Result / Iterations, 1.0, Penumbra);\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), LightTransform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0, 0, 0, 0);\nfloat3 K = Position - Frag.Position;\nfloat3 L = normalize(K);\nfloat A = GetConeAttenuation(K, L, Attenuation.x, Attenuation.y, Range, Direction, Cutoff);\n[branch] if (A <= 0.0)\nreturn float4(0, 0, 0, 0);\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, L, Mat.Scatter) * E;\nfloat4 H = mul(float4(Frag.Position, 1), LightViewProjection);\n#ifdef TARGET_D3D\nfloat2 T = float2(H.x / H.w / 2.0 + 0.5f, 1 - (H.y / H.w / 2.0 + 0.5f));\n#else\nfloat2 T = float2(H.x / H.w / 2.0 + 0.5f, H.y / H.w / 2.0 + 0.5f);\n#endif\n[branch] if (H.z > 0.0 && saturate(T.x) == T.x && saturate(T.y) == T.y)\nA *= GetLightness(T, H.z / H.w - Bias) + length(S) / 3.0;\nreturn float4(Lighting * (R + S) * A, A);\n};";
		callback(context, "lighting/spot/high.hlsl", lighting_spot_high_hlsl, sizeof(lighting_spot_high_hlsl));

		const unsigned char lighting_spot_low_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"lighting/spot/common/buffer.hlsl\"\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), LightTransform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0, 0, 0, 0);\nfloat3 K = Position - Frag.Position;\nfloat3 L = normalize(K);\nfloat A = GetConeAttenuation(K, L, Attenuation.x, Attenuation.y, Range, Direction, Cutoff);\n[branch] if (A <= 0.0)\nreturn float4(0, 0, 0, 0);\nMaterial Mat = Materials[Frag.Material];\nfloat G = GetRoughness(Frag, Mat);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 E = GetSurface(Frag, Mat);\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nfloat3 S = GetSubsurface(Frag.Normal, D, L, Mat.Scatter) * E;\nreturn float4(Lighting * (R + S) * A, A);\n};";
		callback(context, "lighting/spot/low.hlsl", lighting_spot_low_hlsl, sizeof(lighting_spot_low_hlsl));

		const unsigned char lighting_surface_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/position.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nmatrix LightTransform;\nfloat3 Position;\nfloat Range;\nfloat3 Lighting;\nfloat Mips;\nfloat3 Scale;\nfloat Parallax;\nfloat3 Attenuation;\nfloat Infinity;\n};\nTextureCube EnvironmentMap : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = mul(float4(V.Position, 1.0), LightTransform);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0, 0, 0, 0);\nMaterial Mat = Materials[Frag.Material];\n[branch] if (Mat.Environment <= 0.0)\nreturn float4(0.0, 0.0, 0.0, 0.0);\nfloat3 D = Position - Frag.Position;\nfloat3 E = normalize(Frag.Position - vb_Position);\nfloat3 M = GetMetallic(Frag, Mat);\nfloat R = GetRoughness(Frag, Mat);\nfloat A = max(Infinity, GetRangeAttenuation(D, Attenuation.x, Attenuation.y, Range)) * Mat.Environment;\nD = -normalize(reflect(-E, -Frag.Normal));\n[branch] if (Parallax > 0)\n{\nfloat3 Max = Position + Scale;\nfloat3 Min = Position - Scale;\nfloat3 Plane = ((D > 0.0 ? Max : Min) - Frag.Position) / D;\nD = Frag.Position + D * min(min(Plane.x, Plane.y), Plane.z) - Position;\n}\nfloat T = GetRoughnessMip(Frag, Mat, Mips);\n#ifdef TARGET_D3D\nfloat3 P = EnvironmentMap.SampleLevel(Sampler, D, T).xyz;\n#else\nfloat3 P = EnvironmentMap.SampleLevel(Sampler, float3(D.x, -D.y, D.z), T).xyz;\n#endif\nfloat3 C = GetSpecularBRDF(Frag.Normal, -E, normalize(D), P, M, R);\nreturn float4(Lighting * C * A, A);\n};";
		callback(context, "lighting/surface.hlsl", lighting_surface_hlsl, sizeof(lighting_surface_hlsl));

		const unsigned char lighting_voxelize_hlsl[] = "#include \"std/channels/rvoxelizer.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"lighting/point/common/array.hlsl\"\n#include \"lighting/spot/common/array.hlsl\"\n#include \"lighting/line/common/array.hlsl\"\nstatic const float Alpha = 0.005;\nfloat GetDensity(float Density)\n{\nreturn Density / max(1.0, vxb_Lights.x + vxb_Lights.y + vxb_Lights.z);\n}\nfloat GetShadow(float3 Position, float3 Direction, float Length) \n{\nconst float Steps = 48;\nfloat Step = Length / (Steps + 1.0);\nfloat Result = 0.0;\nfor (float i = 0.0; i < Steps; i++)\n{\nfloat Distance = Step * (i + 2.0);\nfloat3 Voxel = Position + Direction * Distance;\n[branch] if (Result >= 1.0 || !IsInVoxelGrid(Voxel))\nbreak;\nfloat Density = ceil(GetDiffuse((uint3)Voxel).w);\nResult += (1.0 - Result) * Density / Distance;\n}\nreturn 1.0 - Result * Steps * vxb_Bleeding;\n}\n[numthreads(8, 8, 8)]\nvoid cs_main(uint3 Voxel : SV_DispatchThreadID)\n{\nfloat4 Diffuse = GetDiffuse(Voxel);\n[branch] if (Diffuse.w < Alpha || (Diffuse.x < Alpha && Diffuse.y < Alpha && Diffuse.z < Alpha))\nreturn;\nFragment Frag = GetFragmentWithDiffuse(Diffuse, Voxel);\nMaterial Mat = Materials[Frag.Material];\n float Transparency = pow(1.0 - Mat.Transparency, 4);\n [branch] if (Transparency < Alpha)\n return;\nfloat G = GetRoughness(Frag, Mat), i;\nfloat3 M = GetMetallic(Frag, Mat);\nfloat3 D = normalize(vb_Position - Frag.Position);\nfloat4 Result = float4(GetEmission(Frag, Mat), 0.0);\nfloat3 Origin = (float3)Voxel;\n[loop] for (i = 0; i < vxb_Lights.x; i++)\n{\nPointLight Light = PointLights[i];\nfloat3 K = Light.Position - Frag.Position;\nfloat A = GetRangeAttenuation(K, Light.Attenuation.x, Light.Attenuation.y, Light.Range);\n[branch] if (A <= Alpha)\ncontinue;\n[branch] if (Light.Softness > 0.0 && vxb_Bleeding > 0.0)\n{\nfloat3 V = GetVoxel(Light.Position) - Origin;\nA *= GetShadow(Origin, normalize(V), length(V));\n}\nfloat3 L = normalize(K);\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nResult += float4(Light.Lighting * R, 1.0) * A;\n}\n[loop] for (i = 0; i < vxb_Lights.y; i++)\n{\nSpotLight Light = SpotLights[i];\nfloat3 K = Light.Position - Frag.Position;\nfloat3 L = normalize(K);\nfloat A = GetConeAttenuation(K, L, Light.Attenuation.x, Light.Attenuation.y, Light.Range, Light.Direction, Light.Cutoff);\n[branch] if (A <= Alpha)\ncontinue;\n[branch] if (Light.Softness > 0.0 && vxb_Bleeding > 0.0)\n{\nfloat3 V = GetVoxel(Light.Position) - Origin;\nA *= GetShadow(Origin, normalize(V), length(V));\n}\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, L, Frag.Diffuse, M, G);\nResult += float4(Light.Lighting * R, 1.0) * A;\n}\n[loop] for (i = 0; i < vxb_Lights.z; i++)\n{\nLineLight Light = LineLights[i]; float A = 1.0;\n[branch] if (Light.Softness > 0.0 && vxb_Bleeding > 0.0)\n{\nfloat3 V = Light.Position * float3(1.0, -1.0, 1.0);\nA = GetShadow(Origin, V, vxb_Size.x);\n}\nfloat3 R = GetCookTorranceBRDF(Frag.Normal, D, Light.Position, Frag.Diffuse, M, G);\nResult += float4(Light.Lighting * R, 1.0) * A;\n}\nResult.w = min(1.0, Mat.Emission.w + GetDensity(Result.w));\n LightBuffer[Voxel] += Result * Transparency;\n};";
		callback(context, "lighting/voxelize.hlsl", lighting_voxelize_hlsl, sizeof(lighting_voxelize_hlsl));

		const unsigned char postprocess_additive_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat3 A = GetDiffuse(V.TexCoord.xy, 0).xyz;\nfloat3 B = Image.SampleLevel(Sampler, V.TexCoord.xy, 0).xyz;\nreturn float4(A + B, 1.0);\n};";
		callback(context, "postprocess/additive.hlsl", postprocess_additive_hlsl, sizeof(postprocess_additive_hlsl));

		const unsigned char postprocess_bloom_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat2 Padding;\nfloat Intensity;\nfloat Threshold;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat3 Color = GetDiffuse(V.TexCoord.xy, 0).xyz;\nreturn float4(max(0.0, Color - Threshold) * Intensity, 1.0);\n};";
		callback(context, "postprocess/bloom.hlsl", postprocess_bloom_hlsl, sizeof(postprocess_bloom_hlsl));

		const unsigned char postprocess_denoise_x_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat3 Padding;\nfloat Cutoff;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nfloat3 N = GetNormal(UV);\nfloat3 B = float3(0, 0, 0);\nfloat I = 0.0;\n[loop] for (int i = 0; i < Samples; i++)\n{\nfloat2 T = UV + float2(Gaussian[i].x, 0) * Texel * Blur;\n[branch] if (dot(GetNormal(T), N) < 0.9)\ncontinue;\nB += Image.SampleLevel(Sampler, T, 0).xyz; I++;\n}\nreturn float4(B / max(1.0, I), 1.0);\n};";
		callback(context, "postprocess/denoise-x.hlsl", postprocess_denoise_x_hlsl, sizeof(postprocess_denoise_x_hlsl));

		const unsigned char postprocess_denoise_y_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat3 Padding;\nfloat Cutoff;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nfloat3 N = GetNormal(UV);\nfloat3 B = float3(0, 0, 0);\nfloat I = 0.0;\n[loop] for (int i = 0; i < Samples; i++)\n{\nfloat2 T = UV + float2(0, Gaussian[i].y) * Texel * Blur;\n[branch] if (dot(GetNormal(T), N) < Cutoff)\ncontinue;\nB += Image.SampleLevel(Sampler, T, 0).xyz; I++;\n}\nreturn float4(B / max(1.0, I), 1.0);\n};";
		callback(context, "postprocess/denoise-y.hlsl", postprocess_denoise_y_hlsl, sizeof(postprocess_denoise_y_hlsl));

		const unsigned char postprocess_fibo_x_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat3 Padding;\nfloat Power;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nfloat3 B = float3(0, 0, 0);\n[loop] for (int i = 0; i < Samples; i++)\n{\nfloat2 T = UV + float2(Gaussian[i].x, 0) * Texel * Blur;\nB += Image.SampleLevel(Sampler, T, 0).xyz;\n}\nreturn float4(B * Power / Samples, 1.0);\n};";
		callback(context, "postprocess/fibo-x.hlsl", postprocess_fibo_x_hlsl, sizeof(postprocess_fibo_x_hlsl));

		const unsigned char postprocess_fibo_y_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat3 Padding;\nfloat Power;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nfloat3 B = float3(0, 0, 0);\n[loop] for (int i = 0; i < Samples; i++)\n{\nfloat2 T = UV + float2(0, Gaussian[i].y) * Texel * Blur;\nB += Image.SampleLevel(Sampler, T, 0).xyz;\n}\nreturn float4(B * Power / Samples, 1.0);\n};";
		callback(context, "postprocess/fibo-y.hlsl", postprocess_fibo_y_hlsl, sizeof(postprocess_fibo_y_hlsl));

		const unsigned char postprocess_focus_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/position.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat2 Texel;\nfloat Radius;\nfloat Bokeh;\nfloat3 Padding;\nfloat Scale;\nfloat NearDistance;\nfloat NearRange;\nfloat FarDistance;\nfloat FarRange;\n}\nfloat GetWeight(float2 TexCoord, float NearD, float NearR, float FarD, float FarR)\n{\nfloat4 Position = mul(float4(GetPosition(TexCoord, GetDepth(TexCoord)), 1.0), vb_ViewProj);\nfloat N = 1.0 - (Position.z - NearD) / NearR;\nfloat F = (Position.z - (FarD - FarR)) / FarR;\nreturn saturate(max(N, F));\n}\nvoid Blur(inout float3 Linear, inout float3 Gamma, float2 UV, float2 Amount, float X, float Y)\n{\nfloat2 Offset = UV + float2(X, Y) * Amount;\nfloat3 Color = GetDiffuse(saturate(Offset), 0).xyz;\nfloat3 Factor = 1.0 + pow(Color, 4.0) * Bokeh;\nLinear += Color * Factor;\nGamma += Factor;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 UV = GetTexCoord(V.TexCoord);\nfloat Amount = Radius * GetWeight(UV, NearDistance, NearRange, FarDistance, FarRange);\nfloat x = 0.0, y = 0.0;\n[branch] if (Amount <= 0.001)\nreturn GetDiffuse(UV, 0);\nfloat2 Offset = Texel * Amount;\nfloat3 Linear = 0.0;\nfloat3 Gamma = 0.000001;\n[loop] for (y = -7.0 + Scale; y <= 7.0 - Scale; y += 1.0)\n{\n[loop] for (x = -7.0 + Scale; x <= 7.0 - Scale; x += 1.0)\nBlur(Linear, Gamma, UV, Offset, x, y);\n}\n[loop] for (x = -5.0 + Scale; x <= 5.0 - Scale; x += 1.0)\n{\nBlur(Linear, Gamma, UV, Offset, x, -8.0 + Scale);\nBlur(Linear, Gamma, UV, Offset, x, 8.0 - Scale);\n}\n[loop] for (y = -5.0 + Scale; y <= 5.0 - Scale; y += 1.0)\n{\nBlur(Linear, Gamma, UV, Offset, -8.0 + Scale, y);\nBlur(Linear, Gamma, UV, Offset, 8.0 - Scale, y);\n}\n[loop] for (x = -3.0 + Scale; x <= 3.0 - Scale; x += 1.0)\n{\nBlur(Linear, Gamma, UV, Offset, x, -9.0 + Scale);\nBlur(Linear, Gamma, UV, Offset, x, 9.0 - Scale);\n}\n[loop] for (y = -3.0 + Scale; y <= 3.0 - Scale; y += 1.0)\n{\nBlur(Linear, Gamma, UV, Offset, -9.0 + Scale, y);\nBlur(Linear, Gamma, UV, Offset, 9.0 - Scale, y);\n}\nreturn float4(Linear / Gamma, 1.0);\n}";
		callback(context, "postprocess/focus.hlsl", postprocess_focus_hlsl, sizeof(postprocess_focus_hlsl));

		const unsigned char postprocess_glitch_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat ScanLineJitterDisplacement;\nfloat ScanLineJitterThreshold;\nfloat VerticalJumpAmount;\nfloat VerticalJumpTime;\nfloat ColorDriftAmount;\nfloat ColorDriftTime;\nfloat HorizontalShake;\nfloat ElapsedTime;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat Jitter = RandomFloatXY(V.TexCoord.y, ElapsedTime) * 2.0 - 1.0;\nJitter *= step(ScanLineJitterThreshold, abs(Jitter)) * ScanLineJitterDisplacement;\nfloat Jump = lerp(V.TexCoord.y, frac(V.TexCoord.y + VerticalJumpTime), VerticalJumpAmount);\nfloat Shake = (RandomFloatXY(ElapsedTime, 2) - 0.5) * HorizontalShake;\nfloat Drift = sin(Jump + ColorDriftTime) * ColorDriftAmount;\nfloat4 Alpha = GetDiffuse(frac(float2(V.TexCoord.x + Jitter + Shake, Jump)), 0);\nfloat4 Beta = GetDiffuse(frac(float2(V.TexCoord.x + Jitter + Shake + Drift, Jump)), 0);\nreturn float4(Alpha.r, Beta.g, Alpha.b, 1);\n};";
		callback(context, "postprocess/glitch.hlsl", postprocess_glitch_hlsl, sizeof(postprocess_glitch_hlsl));

		const unsigned char postprocess_gloss_x_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat Padding;\nfloat Deadzone;\nfloat Mips;\nfloat Cutoff;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nFragment Frag = GetFragment(UV);\nMaterial Mat = Materials[Frag.Material];\nfloat3 Normal = GetNormal(UV);\nfloat Roughness = GetRoughness(Frag, Mat);\nfloat Power = Roughness < Deadzone ? 0.0 : Roughness;\nfloat Force = Blur * Power;\nfloat3 Blurring = float3(0, 0, 0);\nfloat Count = max(1.0, Samples * Power);\nfloat Iterations = 0.0;\n[loop] for (float i = 0; i < Count; i++)\n{\nfloat2 T = UV + float2(Gaussian[i].x, 0) * Texel * Force;\n[branch] if (dot(GetNormal(T), Normal) < Cutoff)\ncontinue;\nBlurring += Image.SampleLevel(Sampler, T, 0).xyz;\nIterations++;\n}\nreturn float4(Blurring / max(1.0, Iterations), 1.0);\n};";
		callback(context, "postprocess/gloss-x.hlsl", postprocess_gloss_x_hlsl, sizeof(postprocess_gloss_x_hlsl));

		const unsigned char postprocess_gloss_y_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat Padding;\nfloat Deadzone;\nfloat Mips;\nfloat Cutoff;\nfloat2 Texel;\nfloat Samples;\nfloat Blur;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\nFragment Frag = GetFragment(UV);\nMaterial Mat = Materials[Frag.Material];\nfloat3 Normal = GetNormal(UV);\nfloat Roughness = GetRoughness(Frag, Mat);\nfloat Power = Roughness < Deadzone ? 0.0 : Roughness;\nfloat Force = Blur * Power;\nfloat3 Blurring = float3(0, 0, 0);\nfloat Count = max(1.0, Samples * Power);\nfloat Iterations = 0.0;\n[loop] for (float i = 0; i < Count; i++)\n{\nfloat2 T = UV + float2(0, Gaussian[i].x) * Texel * Force;\n[branch] if (dot(GetNormal(T), Normal) < Cutoff)\ncontinue;\nBlurring += Image.SampleLevel(Sampler, T, 0).xyz;\nIterations++;\n}\nreturn float4(Blurring / max(1.0, Iterations), 1.0);\n};";
		callback(context, "postprocess/gloss-y.hlsl", postprocess_gloss_y_hlsl, sizeof(postprocess_gloss_y_hlsl));

		const unsigned char postprocess_indirection_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/raymarching.hlsl\"\n#include \"std/core/random.hlsl\"\nTexture2D StochasticNormalMap : register(t5);\nTexture2D EmissionMap : register(t6);\ncbuffer RenderConstant : register(b3)\n{\n float2 Random;\nfloat Samples;\nfloat Distance;\n float Initial;\n float Cutoff;\n float Attenuation;\n float Swing;\n float3 Padding;\n float Bias;\n}\nstatic const float3 RayCastingSphere[16] =\n{\n float3(0.5381, 0.1856, -0.4319),\n float3(0.1379, 0.2486, 0.4430),\n float3(0.3371, 0.5679, -0.0057),\n float3(-0.6999, -0.0451, -0.0019),\n float3(0.0689, -0.1598, -0.8547),\n float3(0.0560, 0.0069, -0.1843),\n float3(-0.0146, 0.1402, 0.0762),\n float3(0.0100, -0.1924, -0.0344),\n float3(-0.3577, -0.5301, -0.4358),\n float3(-0.3169, 0.1063, 0.0158),\n float3(0.0103, -0.5869, 0.0046),\n float3(-0.0897, -0.4940, 0.3287),\n float3(0.7119, -0.0154, -0.0918),\n float3(-0.0533, 0.0596, -0.5411),\n float3(0.0352, -0.0631, 0.5460),\n float3(-0.4776, 0.2847, -0.0271)\n};\nfloat3 GetLightAt(float2 TexCoord)\n{\n float Emission = SurfaceBuffer.SampleLevel(Sampler, TexCoord, 0).w;\n float3 Light = EmissionMap.SampleLevel(Sampler, TexCoord, 0).xyz;\n Light += Light * Emission;\n return Swing * pow(abs(Light), 1.0 / Attenuation);\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float2 UV = GetTexCoord(V.TexCoord);\n float3 Color = EmissionMap.SampleLevel(Sampler, UV, 0).xyz;\n if (Initial > 0.0)\n Color = float3(0.0, 0.0, 0.0);\n \nFragment Frag = GetFragment(UV);\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(Color.xyz, 1.0);\nMaterial Mat = Materials[Frag.Material];\nfloat3 Metallic = 1.0 - GetMetallic(Frag, Mat);\n float3 Accumulation = 0.0;\n float2 Jitter = RandomFloat2(UV + Random) + 0.5;\nfloat4 Normal = StochasticNormalMap.SampleLevel(Sampler, UV, 0);\n float Step = (1.0 / (float)Samples), Counter = 0.0;\n Step = Step * (Jitter.x + Jitter.y) + Step;\n for (float i = 0; i < Samples; i++)\n {\n float3 Direction = normalize(Normal.xyz + RayCastingSphere[i]);\n [branch] if (dot(Frag.Normal, Direction) < Cutoff)\n continue;\n float3 TexCoord = Raymarch(Frag.Position, Direction, Samples, Step * Distance);\n [branch] if (TexCoord.z == -1.0)\n continue;\n float3 Light = GetLightAt(TexCoord.xy);\n float Emission = distance(Frag.Position, GetPosition(TexCoord.xy, TexCoord.z)) / Distance;\n Emission = Bias * Emission * length(Light) / 3.0;\n Accumulation += Light * (1.0 - Emission * Emission);\n Counter++;\n }\n if (Counter > 0.0)\n Accumulation /= Counter;\n \n return float4(Color + Metallic * Accumulation, 1.0);\n};";
		callback(context, "postprocess/indirection.hlsl", postprocess_indirection_hlsl, sizeof(postprocess_indirection_hlsl));

		const unsigned char postprocess_luminance_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat2 Texel;\nfloat Mips;\nfloat Time;\n}\nTexture2D LUT : register(t6);\nfloat GetAvg(float2 TexCoord)\n{\nfloat3 Color = GetDiffuseSample(TexCoord).xyz;\nreturn (Color.x + Color.y + Color.z) / 3.0;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat ps_main(VOutput V) : SV_TARGET0\n{\nfloat Result = 0.0;\n[unroll] for (float i = 0; i < 16.0; i++)\nResult += GetAvg(V.TexCoord.xy + Gaussian[i] * Texel);\nfloat Subresult = LUT.Sample(Sampler, V.TexCoord.xy).r;\nreturn Subresult + (Result / 4.0 - Subresult) * (1.0 - exp(-Time));\n};";
		callback(context, "postprocess/luminance.hlsl", postprocess_luminance_hlsl, sizeof(postprocess_luminance_hlsl));

		const unsigned char postprocess_motion_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat Samples;\nfloat Blur;\nfloat Motion;\nfloat Padding;\n}\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = V.TexCoord.xy;\nfloat2 Velocity = Image.Sample(Sampler, TexCoord).xy * Motion;\nfloat3 Result = GetDiffuse(TexCoord, 0).xyz;\nTexCoord += Velocity;\n[loop] for (float i = 1.0; i < Samples; ++i)\n{\nfloat2 T = TexCoord + Velocity * Gaussian[i] * Blur;\nResult += GetDiffuse(T, 0).xyz;\n}\nreturn float4(Result / Samples, 1.0); \n};";
		callback(context, "postprocess/motion.hlsl", postprocess_motion_hlsl, sizeof(postprocess_motion_hlsl));

		const unsigned char postprocess_multiply_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\nTexture2D Image : register(t5);\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat3 A = GetDiffuse(V.TexCoord.xy, 0).xyz;\nfloat3 B = Image.SampleLevel(Sampler, V.TexCoord.xy, 0).xyz;\nreturn float4(A * B, 1.0);\n};";
		callback(context, "postprocess/multiply.hlsl", postprocess_multiply_hlsl, sizeof(postprocess_multiply_hlsl));

		const unsigned char postprocess_reflectance_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/raymarching.hlsl\"\n#include \"std/core/position.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat Samples;\nfloat Padding;\nfloat Intensity;\nfloat Distance;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nFragment Frag = GetFragment(GetTexCoord(V.TexCoord));\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(0.0, 0.0, 0.0, 1.0);\nfloat3 Eye = normalize(Frag.Position - vb_Position);\nfloat3 Direction = reflect(Eye, Frag.Normal);\nfloat Fix = Rayprefix(Eye, Direction);\n[branch] if (Fix <= 0.0)\nreturn float4(0.0, 0.0, 0.0, 1.0);\nMaterial Mat = Materials[Frag.Material];\nfloat Fading = 1.0 - GetRoughnessMip(Frag, Mat, 1.0);\nfloat Step = Fading * Distance / Samples;\n[branch] if (Fading <= 0.0)\nreturn float4(0.0, 0.0, 0.0, 1.0);\nfloat3 TexCoord = Raymarch(Frag.Position, Direction, Samples, Step);\n[branch] if (TexCoord.z < 0.0)\nreturn float4(0.0, 0.0, 0.0, 1.0);\nfloat3 Metallic = GetMetallic(Frag, Mat);\nfloat3 Color = GetDiffuse(TexCoord.xy, 0).xyz * Intensity;\nFix *= Raypostfix(TexCoord.xy, Direction);\nreturn float4(Metallic * Color * Fix, 1.0);\n};";
		callback(context, "postprocess/reflectance.hlsl", postprocess_reflectance_hlsl, sizeof(postprocess_reflectance_hlsl));

		const unsigned char postprocess_shading_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/random.hlsl\"\n#include \"std/core/position.hlsl\"\n#include \"std/core/material.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat Samples;\nfloat Intensity;\nfloat Scale;\nfloat Bias;\nfloat Radius;\nfloat Distance;\nfloat Fade;\nfloat Padding;\n}\nfloat GetFactor(float2 TexCoord, float3 Position, float3 Normal, float Power) \n{\nfloat3 D = GetPosition(TexCoord, GetDepth(TexCoord)) - Position; \nfloat3 V = normalize(D); \nfloat T = length(D) * Scale; \nreturn max(0.0, dot(Normal, V) - Bias) * (1.0 / (1.0 + T)) * Power;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nconst float2 Disk[4] = { float2(1, 0), float2(-1, 0), float2(0, 1), float2(0, -1) };\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nFragment Frag = GetFragment(TexCoord);\n[branch] if (Frag.Depth >= 1.0)\nreturn float4(1.0, 1.0, 1.0, 1.0);\nMaterial Mat = Materials[Frag.Material];\nfloat2 Random = RandomFloat2(TexCoord);\nfloat Vision = saturate(pow(abs(distance(vb_Position, Frag.Position) / Distance), Fade));\nfloat Power = Intensity * GetOcclusion(Frag, Mat);\nfloat Size = (Radius + Mat.Radius) / Frag.Depth;\nfloat Factor = 0.0;\n[loop] for (int j = 0; j < Samples; ++j) \n{\nfloat2 C1 = reflect(Disk[j], Random) * Size; \nfloat2 C2 = float2(C1.x * 0.707 - C1.y * 0.707, C1.x * 0.707 + C1.y * 0.707); \nFactor += GetFactor(TexCoord + C1 * 0.25, Frag.Position, Frag.Normal, Power); \nFactor += GetFactor(TexCoord + C2 * 0.5, Frag.Position, Frag.Normal, Power);\nFactor += GetFactor(TexCoord + C1 * 0.75, Frag.Position, Frag.Normal, Power);\nFactor += GetFactor(TexCoord + C2, Frag.Position, Frag.Normal, Power);\n}\nFactor /= Samples * Samples; \nreturn 1.0 - Factor * Vision;\n};";
		callback(context, "postprocess/shading.hlsl", postprocess_shading_hlsl, sizeof(postprocess_shading_hlsl));

		const unsigned char postprocess_stochastic_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat2 Texel;\n float FrameId;\nfloat Padding;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat GetAnimatedInterlavedGradientNoise(float2 TexCoord)\n{\n uint Frame = uint(FrameId);\n float2 UV = TexCoord * Texel;\n if ((Frame & 2) != 0)\n UV = float2(-UV.y, UV.x);\n \n if ((Frame & 1) != 0)\n UV.x = -UV.x;\n \n return frac(UV.x * 0.7548776662 + UV.y * 0.56984029 + float(Frame) * 0.41421356);\n}\nfloat3 GetPerpendicularVector(float3 Value)\n{\n float3 Axis = abs(Value);\n if (Axis.x < Axis.y)\n return Axis.x < Axis.z ? float3(0, -Value.z, Value.y) : float3(-Value.y, Value.x, 0);\n \n return Axis.y < Axis.z ? float3(Value.z, 0, -Value.x) : float3(-Value.y, Value.x, 0);\n}\nfloat3 GetCosHemisphereSample(float Random1, float Random2, float3 Normal)\n{\nfloat2 Direction = float2(Random1, Random2);\nfloat3 Bitangent = GetPerpendicularVector(Normal);\nfloat3 Tangent = cross(Bitangent, Normal);\nfloat Radius = sqrt(Direction.x);\nfloat PHI = 2.0f * 3.14159265f * Direction.y;\nreturn Tangent * (Radius * cos(PHI).x) + Bitangent * (Radius * sin(PHI)) + Normal.xyz * sqrt(max(0.0, 1.0f - Direction.x));\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\n float3 Normal = GetNormal(V.TexCoord.xy);\n float Noise = GetAnimatedInterlavedGradientNoise(V.TexCoord.xy);\n float3 StochasticNormal = GetCosHemisphereSample(Noise, Noise, Normal);\n return normalize(float4(StochasticNormal, 1.0));\n};";
		callback(context, "postprocess/stochastic.hlsl", postprocess_stochastic_hlsl, sizeof(postprocess_stochastic_hlsl));

		const unsigned char postprocess_tone_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nfloat2 Padding;\nfloat Grayscale;\nfloat ACES;\nfloat Filmic;\nfloat Lottes;\nfloat Reinhard;\nfloat Reinhard2;\nfloat Unreal;\nfloat Uchimura;\nfloat UBrightness;\nfloat UContrast;\nfloat UStart;\nfloat ULength;\nfloat UBlack;\nfloat UPedestal;\nfloat Exposure;\nfloat EIntensity;\nfloat EGamma;\nfloat Adaptation;\nfloat AGray;\nfloat AWhite;\nfloat ABlack;\nfloat ASpeed;\n}\nTexture2D LUT : register(t5);\nfloat3 GetGrayscale(float3 Color)\n{\nreturn (Color.x + Color.y + Color.z) / 3.0;\n}\nfloat3 GetACES(float3 Color)\n{\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn clamp((Color * (A * Color + B)) / (Color * (C * Color + D) + E), 0.0, 1.0);\n}\nfloat3 GetFilmic(float3 Color)\n{\nfloat3 X = max(0.0, Color - 0.004);\nreturn pow(abs((X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06)), 2.2);\n}\nfloat3 GetLottes(float3 Color)\n{\nconst float3 A = 1.6;\nconst float3 D = 0.977;\nconst float3 HDR = 8.0;\nconst float3 In = 0.18;\nconst float3 Out = 0.267;\nconst float3 B = (-pow(abs(In), A) + pow(abs(HDR), A) * Out) / ((pow(abs(HDR), A * D) - pow(abs(In), A * D)) * Out);\nconst float3 C = (pow(abs(HDR), A * D) * pow(abs(In), A) - pow(abs(HDR), A) * pow(abs(In), A * D) * Out) / ((pow(abs(HDR), A * D) - pow(abs(In), A * D)) * Out);\nreturn pow(abs(Color), A) / (pow(abs(Color), A * D) * B + C);\n}\nfloat3 GetReinhard(float3 Color)\n{\nreturn Color / (1.0 + Color);\n}\nfloat3 GetReinhard2(float3 Color)\n{\nconst float White = 4.0 * 4.0;\nreturn (Color * (1.0 + Color / White)) / (1.0 + Color);\n}\nfloat3 GetUnreal(float3 Color)\n{\nreturn Color / (Color + 0.155) * 1.019;\n}\nfloat3 GetUchimura(float3 Color)\n{\nfloat K0 = ((UBrightness - UStart) * ULength) / UContrast;\nfloat L0 = UStart - UStart / UContrast;\nfloat L1 = UStart + (1.0 - UStart) / UContrast;\nfloat S0 = UStart + K0;\nfloat S1 = UStart + UContrast * K0;\nfloat C2 = (UContrast * UBrightness) / (UBrightness - S1);\nfloat CP = -C2 / UBrightness;\nfloat3 W0 = 1.0 - smoothstep(0.0, UStart, Color);\nfloat3 W2 = step(UStart + K0, Color);\nfloat3 W1 = 1.0 - W0 - W2;\nfloat3 T = UStart * pow(abs(Color / UStart), UBlack) + UPedestal;\nfloat3 S = UBrightness - (UBrightness - S1) * exp(CP * (Color - S0));\nfloat3 L = UStart + UContrast * (Color - UStart);\nreturn T * W0 + L * W1 + S * W2;\n}\nfloat3 GetExposure(float3 Color)\n{\nfloat3 Result = 1.0 - exp(-Color * EIntensity);\nreturn pow(abs(Result), 1.0 / EGamma);\n}\nfloat3 GetAdaptation(float3 Color)\n{\nfloat Luminance = LUT.Load(int3(0, 0, 0)).r;\nfloat Avg = saturate((Color.x + Color.y + Color.z) / 3.0);\nfloat Exp = AGray / clamp(Luminance, ABlack, AWhite);\nreturn Color * Exp;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord.xy = V.TexCoord;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat3 Result = GetDiffuse(V.TexCoord.xy, 0).xyz;\nResult = lerp(Result, GetAdaptation(Result), Adaptation);\nResult = lerp(Result, GetGrayscale(Result), Grayscale);\nResult = lerp(Result, GetACES(Result), ACES);\nResult = lerp(Result, GetFilmic(Result), Filmic);\nResult = lerp(Result, GetLottes(Result), Lottes);\nResult = lerp(Result, GetReinhard(Result), Reinhard);\nResult = lerp(Result, GetReinhard2(Result), Reinhard2);\nResult = lerp(Result, GetUnreal(Result), Unreal);\nResult = lerp(Result, GetUchimura(Result), Uchimura);\nResult = lerp(Result, GetExposure(Result), Exposure);\nreturn float4(Result, 1.0);\n};";
		callback(context, "postprocess/tone.hlsl", postprocess_tone_hlsl, sizeof(postprocess_tone_hlsl));

		const unsigned char postprocess_transparency_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/position.hlsl\"\n#pragma warning(disable: 4000)\ncbuffer RenderConstant : register(b3)\n{\nfloat3 Padding;\nfloat Mips;\n}\nTexture2D LDiffuseBuffer : register(t5);\nTexture2D LNormalBuffer : register(t6);\nTexture2D LDepthBuffer : register(t7);\nTexture2D LSurfaceBuffer : register(t8);\nfloat3 GetOpaque(float2 TexCoord, float D2, float L)\n{\n[branch] if (D2 >= 1.0)\nreturn GetDiffuse(TexCoord, L).xyz;\nfloat3 Position = GetPosition(TexCoord, D2);\nfloat3 Eye = normalize(Position - vb_Position);\nfloat4 Normal = NormalBuffer.Sample(Sampler, TexCoord);\nreturn GetDiffuse(TexCoord, L).xyz;\n}\nfloat3 GetCoverage(float2 TexCoord, float L)\n{\nreturn GetOpaque(TexCoord, GetDepth(TexCoord), L);\n}\nfloat2 GetUV(float2 TexCoord, float L, float V)\n{\nfloat2 T = TexCoord - 0.5;\nfloat R = T.x * T.x + T.y * T.y;\nfloat F = 1.0 + R * (lerp(0, V, abs(L)) - L);\nreturn F * T + 0.5;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nfloat D1 = LDepthBuffer.SampleLevel(Sampler, TexCoord, 0).x;\nfloat D2 = GetDepth(TexCoord);\n[branch] if (D2 < D1 || D1 >= 1.0)\nreturn float4(GetOpaque(TexCoord, D2, 0.0), 1.0);\nfloat3 Position = GetPosition(TexCoord, D1);\nfloat3 Eye = normalize(Position - vb_Position);\nfloat4 Normal = LNormalBuffer.Sample(Sampler, TexCoord);\nMaterial Mat = Materials[Normal.w];\nfloat4 Diffuse = LDiffuseBuffer.Sample(Sampler, TexCoord);\nfloat A = min(1.0, (1.0 - Diffuse.w) + Mat.Transparency);\nfloat R = max(0.0, Mat.Roughness.x + LSurfaceBuffer.Sample(Sampler, TexCoord).x * Mat.Roughness.y - 0.25) / 0.75;\nDiffuse.x += GetCoverage(GetUV(TexCoord, Mat.Refraction, 0.05), R * Mips).x * A;\nDiffuse.y += GetCoverage(GetUV(TexCoord, Mat.Refraction, 0.0), R * Mips).y * A;\nDiffuse.z += GetCoverage(GetUV(TexCoord, Mat.Refraction, -0.05), R * Mips).z * A;\nreturn float4(Diffuse.xyz, 1.0 - A);\n};";
		callback(context, "postprocess/transparency.hlsl", postprocess_transparency_hlsl, sizeof(postprocess_transparency_hlsl));

		const unsigned char postprocess_velocity_hlsl[] = "#include \"std/layouts/shape.hlsl\"\n#include \"std/channels/effect.hlsl\"\n#include \"std/core/position.hlsl\"\ncbuffer RenderConstant : register(b3)\n{\nmatrix LastViewProjection;\n}\nVOutput vs_main(VInput V)\n{\nVOutput Result = (VOutput)0;\nResult.Position = float4(V.Position, 1.0);\nResult.TexCoord = Result.Position;\nreturn Result;\n}\nfloat4 ps_main(VOutput V) : SV_TARGET0\n{\nfloat2 TexCoord = GetTexCoord(V.TexCoord);\nfloat3 Origin = GetPosition(TexCoord, GetDepth(TexCoord));\nfloat4 Offset = mul(float4(Origin, 1.0), LastViewProjection);\nfloat2 Delta = (V.TexCoord.xy - Offset.xy / Offset.w) / 2.0;\nreturn float4(Delta, 0.0, 1.0);\n};";
		callback(context, "postprocess/velocity.hlsl", postprocess_velocity_hlsl, sizeof(postprocess_velocity_hlsl));

		const unsigned char std_buffers_animation_hlsl[] = "cbuffer ab_Animated : register(b0)\n{\nmatrix ab_Offsets[96];\nfloat3 ab_Padding;\nfloat ab_Animated;\n};";
		callback(context, "std/buffers/animation.hlsl", std_buffers_animation_hlsl, sizeof(std_buffers_animation_hlsl));

		const unsigned char std_buffers_cubic_hlsl[] = "cbuffer RenderConstant : register(b3)\n{\nmatrix cb_ViewProjection[6];\n};";
		callback(context, "std/buffers/cubic.hlsl", std_buffers_cubic_hlsl, sizeof(std_buffers_cubic_hlsl));

		const unsigned char std_buffers_object_hlsl[] = "cbuffer Object : register(b1)\n{\nmatrix ob_Transform;\nmatrix ob_World;\nfloat4 ob_TexCoord;\nfloat ob_Diffuse;\nfloat ob_Normal;\nfloat ob_Height;\nfloat ob_MaterialId;\n};";
		callback(context, "std/buffers/object.hlsl", std_buffers_object_hlsl, sizeof(std_buffers_object_hlsl));

		const unsigned char std_buffers_viewer_hlsl[] = "cbuffer Viewer : register(b2)\n{\nmatrix vb_InvViewProj;\nmatrix vb_ViewProj;\nmatrix vb_Proj;\nmatrix vb_View;\nfloat3 vb_Position;\nfloat vb_Far;\nfloat3 vb_Direction;\nfloat vb_Near;\n};";
		callback(context, "std/buffers/viewer.hlsl", std_buffers_viewer_hlsl, sizeof(std_buffers_viewer_hlsl));

		const unsigned char std_buffers_voxelizer_hlsl[] = "cbuffer Voxelizer : register(b3)\n{\nmatrix vxb_Transform;\nfloat3 vxb_Center;\nfloat vxb_Step;\nfloat3 vxb_Size;\nfloat vxb_Mips;\nfloat3 vxb_Scale;\nfloat vxb_MaxSteps;\nfloat3 vxb_Lights;\nfloat vxb_Radiance;\nfloat vxb_Margin;\nfloat vxb_Offset;\nfloat vxb_Angle;\nfloat vxb_Length;\nfloat vxb_Distance;\nfloat vxb_Occlusion;\nfloat vxb_Specular;\nfloat vxb_Bleeding;\n};";
		callback(context, "std/buffers/voxelizer.hlsl", std_buffers_voxelizer_hlsl, sizeof(std_buffers_voxelizer_hlsl));

		const unsigned char std_channels_depth_hlsl[] = "#include \"std/objects/material.hlsl\"\n#pragma warning(disable: 4000)\nStructuredBuffer<Material> Materials : register(t0);\nTexture2D DiffuseMap : register(t1);\nSamplerState Sampler : register(s1);\nfloat4 GetDiffuse(float2 TexCoord)\n{\nreturn DiffuseMap.Sample(Sampler, TexCoord);\n}";
		callback(context, "std/channels/depth.hlsl", std_channels_depth_hlsl, sizeof(std_channels_depth_hlsl));

		const unsigned char std_channels_effect_hlsl[] = "#include \"std/buffers/viewer.hlsl\"\n#include \"std/objects/material.hlsl\"\n#include \"std/objects/fragment.hlsl\"\n#include \"std/core/position.hlsl\"\nStructuredBuffer<Material> Materials : register(t0);\nTexture2D DiffuseBuffer : register(t1);\nTexture2D NormalBuffer : register(t2);\nTexture2D DepthBuffer : register(t3);\nTexture2D SurfaceBuffer : register(t4);\nSamplerState Sampler : register(s1);\nbool IsInPixelGrid(float2 TexCoord)\n{\nreturn TexCoord.x >= 0.0 && TexCoord.x <= 1.0 && TexCoord.y >= 0.0 && TexCoord.y <= 1.0;\n}\nfloat Linearize(float Depth)\n{\nreturn vb_Near * vb_Far / (vb_Far + Depth * (vb_Near - vb_Far));\n}\nfloat GetDepth(float2 TexCoord)\n{\nreturn DepthBuffer.SampleLevel(Sampler, TexCoord, 0).x;\n}\nfloat3 GetNormal(float2 TexCoord)\n{\nreturn NormalBuffer.SampleLevel(Sampler, TexCoord, 0).xyz;\n}\nfloat4 GetDiffuse(float2 TexCoord, float Level)\n{\nreturn DiffuseBuffer.SampleLevel(Sampler, TexCoord, Level);\n}\nfloat4 GetDiffuseSample(float2 TexCoord)\n{\nreturn DiffuseBuffer.Sample(Sampler, TexCoord);\n}\nFragment GetFragment(float2 TexCoord)\n{\nfloat4 C0 = DiffuseBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C1 = NormalBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C2 = DepthBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C3 = SurfaceBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat3 Position = GetPosition(TexCoord, C2.x);\nFragment Result;\nResult.Position = Position;\nResult.Diffuse = C0.xyz;\nResult.Alpha = C0.w;\nResult.Normal = C1.xyz;\nResult.Material = C1.w;\nResult.Depth = C2.x;\nResult.Roughness = C3.x;\nResult.Metallic = C3.y;\nResult.Occlusion = C3.z;\nResult.Emission = C3.w;\nreturn Result;\n}";
		callback(context, "std/channels/effect.hlsl", std_channels_effect_hlsl, sizeof(std_channels_effect_hlsl));

		const unsigned char std_channels_gbuffer_hlsl[] = "#include \"std/channels/geometry.hlsl\"\n#include \"std/objects/gbuffer.hlsl\"\nGBuffer Compose(float2 TexCoord, float4 Diffuse, float3 Normal, float Depth, float MaterialId)\n{\nGBuffer Result;\nResult.DiffuseBuffer = Diffuse;\nResult.NormalBuffer.xyz = Normal;\nResult.NormalBuffer.w = MaterialId;\nResult.DepthBuffer = Depth;\nResult.SurfaceBuffer.x = RoughnessMap.Sample(Sampler, TexCoord).x;\nResult.SurfaceBuffer.y = MetallicMap.Sample(Sampler, TexCoord).x;\nResult.SurfaceBuffer.z = OcclusionMap.Sample(Sampler, TexCoord).x;\nResult.SurfaceBuffer.w = EmissionMap.Sample(Sampler, TexCoord).x;\nreturn Result;\n}";
		callback(context, "std/channels/gbuffer.hlsl", std_channels_gbuffer_hlsl, sizeof(std_channels_gbuffer_hlsl));

		const unsigned char std_channels_geometry_hlsl[] = "#include \"std/objects/material.hlsl\"\n#include \"std/buffers/viewer.hlsl\"\n#pragma warning(disable: 4000)\nStructuredBuffer<Material> Materials : register(t0);\nTexture2D DiffuseMap : register(t1);\nTexture2D NormalMap : register(t2);\nTexture2D MetallicMap : register(t3);\nTexture2D RoughnessMap : register(t4);\nTexture2D HeightMap : register(t5);\nTexture2D OcclusionMap : register(t6);\nTexture2D EmissionMap : register(t7);\nSamplerState Sampler : register(s1);\nfloat2 GetParallax(float2 TexCoord, float3 Direction, float Amount, float Bias)\n{\nfloat Steps = lerp(32.0, 8.0, pow(1.0 - abs(dot(float3(0.0, 0.0, 1.0), Direction)), 4));\nfloat Step = 1.0 / Steps;\nfloat Depth = 0.0;\nfloat2 Delta = Direction.xy * Amount / Steps;\nfloat2 Result = TexCoord;\nfloat Sample = HeightMap.SampleLevel(Sampler, Result, 0).x + Bias;\n[loop] for (float i = 0; i < Steps; i++)\n{\n[branch] if (Depth >= Sample)\nbreak;\nResult -= Delta;\nSample = HeightMap.SampleLevel(Sampler, Result, 0).x + Bias; \nDepth += Step;\n}\nfloat2 Origin = Result + Delta;\nfloat Depth1 = Sample - Depth;\nfloat Depth2 = HeightMap.SampleLevel(Sampler, Origin, 0).x + Bias - Depth + Step;\nfloat Weight = Depth1 / (Depth1 - Depth2);\nreturn Origin * Weight + Result * (1.0 - Weight);\n}\nfloat3 GetDirection(float3 Tangent, float3 Bitangent, float3 Normal, float4 Position, float2 Scale)\n{\nfloat3x3 TangentSpace;\nTangentSpace[0] = Tangent;\nTangentSpace[1] = Bitangent;\nTangentSpace[2] = Normal;\nTangentSpace = transpose(TangentSpace);\nreturn mul(normalize(vb_Position - Position.xyz), TangentSpace) / float3(Scale, 1.0);\n}\nfloat3 GetNormal(float2 TexCoord, float3 Normal, float3 Tangent, float3 Bitangent)\n{\nfloat3 Result = NormalMap.Sample(Sampler, TexCoord).xyz * 2.0 - 1.0;\nreturn normalize(Result.x * Tangent + Result.y * Bitangent + Result.z * Normal);\n}\nfloat4 GetDiffuse(float2 TexCoord)\n{\nreturn DiffuseMap.Sample(Sampler, TexCoord);\n}";
		callback(context, "std/channels/geometry.hlsl", std_channels_geometry_hlsl, sizeof(std_channels_geometry_hlsl));

		const unsigned char std_channels_gvoxelizer_hlsl[] = "#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/voxelizer.hlsl\"\n#include \"std/core/material.hlsl\"\n#pragma warning(disable: 4000)\nStructuredBuffer<Material> Materials : register(t0);\nRWTexture3D<unorm float4> DiffuseBuffer : register(u1);\nRWTexture3D<float4> NormalBuffer : register(u2);\nRWTexture3D<unorm float4> SurfaceBuffer : register(u3);\nTexture2D DiffuseMap : register(t4);\nTexture2D NormalMap : register(t5);\nTexture2D MetallicMap : register(t6);\nTexture2D RoughnessMap : register(t7);\nTexture2D OcclusionMap : register(t8);\nTexture2D EmissionMap : register(t9);\nSamplerState Sampler : register(s4);\nuint GetVoxelDominant(float3 N1, float3 N2, float3 N3)\n{\nconst float3 Pivot = abs(cross(N2.xyz - N1.xyz, N3.xyz - N1.xyz));\nuint Dominant = 2;\n[branch] if (Pivot.z > Pivot.x && Pivot.z > Pivot.y)\nDominant = 0;\nelse if (Pivot.x > Pivot.y && Pivot.x > Pivot.z)\nDominant = 1;\nreturn Dominant;\n}\nfloat4 GetVoxelPosition(float4 Position, uint Dominant)\n{\n[branch] if (Dominant == 0)\nreturn float4(Position.xy, 0, 1);\nelse if (Dominant == 1)\nreturn float4(Position.yz, 0, 1);\nreturn float4(Position.xz, 1.0, 1.0);\n}\nfloat4 GetVoxel(float4 Position)\n{\nreturn float4(clamp(Position.xyz - vxb_Center, -vxb_Scale, vxb_Scale) / vxb_Scale, 1.0);\n}\nfloat3 GetNormal(float2 TexCoord, float3 Normal, float3 Tangent, float3 Bitangent)\n{\nfloat3 Result = NormalMap.Sample(Sampler, TexCoord).xyz * 2.0 - 1.0;\nreturn normalize(Result.x * Tangent + Result.y * Bitangent + Result.z * Normal);\n}\nfloat4 GetDiffuse(float2 TexCoord)\n{\nreturn DiffuseMap.Sample(Sampler, TexCoord);\n}\nvoid Compose(float2 TexCoord, float4 Diffuse, float3 Normal, float3 Position, float MaterialId)\n{\n[branch] if (Position.x < -1.0 || Position.x > 1.0 || Position.y < -1.0 || Position.y > 1.0 || Position.z < -1.0 || Position.z > 1.0)\nreturn;\nuint3 Voxel = (uint3)floor((float3(0.5, -0.5, 0.5) * Position + 0.5) * vxb_Size);\nDiffuseBuffer[Voxel] = Diffuse;\nNormalBuffer[Voxel] = float4(Normal, MaterialId);\nSurfaceBuffer[Voxel] = float4(\nRoughnessMap.Sample(Sampler, TexCoord).x,\nMetallicMap.Sample(Sampler, TexCoord).x,\nOcclusionMap.Sample(Sampler, TexCoord).x,\nEmissionMap.Sample(Sampler, TexCoord).x);\n}";
		callback(context, "std/channels/gvoxelizer.hlsl", std_channels_gvoxelizer_hlsl, sizeof(std_channels_gvoxelizer_hlsl));

		const unsigned char std_channels_immediate_hlsl[] = "Texture2D DiffuseMap : register(t1);\nSamplerState Sampler : register(s1);\nfloat4 GetDiffuse(float2 TexCoord)\n{\nreturn DiffuseMap.Sample(Sampler, TexCoord);\n}";
		callback(context, "std/channels/immediate.hlsl", std_channels_immediate_hlsl, sizeof(std_channels_immediate_hlsl));

		const unsigned char std_channels_raytracer_hlsl[] = "#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/voxelizer.hlsl\"\n#include \"std/core/material.hlsl\"\n#include \"std/core/lighting.hlsl\"\n#include \"std/core/position.hlsl\"\nStructuredBuffer<Material> Materials : register(t0);\nTexture2D DiffuseBuffer : register(t1);\nTexture2D NormalBuffer : register(t2);\nTexture2D DepthBuffer : register(t3);\nTexture2D SurfaceBuffer : register(t4);\nTexture3D<unorm float4> LightBuffer : register(t5);\nSamplerState Sampler : register(s1);\nbool IsInVoxelGrid(float3 Voxel)\n{\nreturn (Voxel.x > 0.0 && Voxel.x < 1.0 && Voxel.y > 0.0 && Voxel.y < 1.0 && Voxel.z > 0.0 && Voxel.z < 1.0);\n}\nfloat GetAvg(float3 Value)\n{\nreturn (Value.x + Value.y + Value.z) / 3.0;\n}\nfloat3 GetVoxel(float3 Position)\n{\nfloat3 Voxel = clamp(Position - vxb_Center, -vxb_Scale, vxb_Scale) / vxb_Scale;\nreturn (float3(0.5, -0.5, 0.5) * Voxel + 0.5);\n}\nfloat3 GetFlatVoxel(float3 Voxel)\n{\nreturn floor(Voxel * vxb_Size) / vxb_Size;\n}\nfloat4 GetLight(float3 Voxel, float Level)\n{\nreturn LightBuffer.SampleLevel(Sampler, Voxel, Level);\n}\nfloat4 GetDiffuse(float2 TexCoord)\n{\nreturn DiffuseBuffer.SampleLevel(Sampler, TexCoord, 0);\n}\nFragment GetFragment(float2 TexCoord)\n{\nfloat4 C0 = DiffuseBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C1 = NormalBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C2 = DepthBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat4 C3 = SurfaceBuffer.SampleLevel(Sampler, TexCoord, 0);\nfloat3 Position = GetPosition(TexCoord, C2.x);\nbool Usable = IsInVoxelGrid(GetVoxel(Position));\nFragment Result;\nResult.Position = Position;\nResult.Diffuse = C0.xyz;\nResult.Alpha = C0.w;\nResult.Normal = C1.xyz;\nResult.Material = C1.w;\nResult.Depth = (Usable ? C2.x : 2.0);\nResult.Roughness = C3.x;\nResult.Metallic = C3.y;\nResult.Occlusion = C3.z;\nResult.Emission = C3.w;\nreturn Result;\n}";
		callback(context, "std/channels/raytracer.hlsl", std_channels_raytracer_hlsl, sizeof(std_channels_raytracer_hlsl));

		const unsigned char std_channels_rvoxelizer_hlsl[] = "#include \"std/buffers/viewer.hlsl\"\n#include \"std/buffers/voxelizer.hlsl\"\n#include \"std/core/material.hlsl\"\n#pragma warning(disable: 4000)\nStructuredBuffer<Material> Materials : register(t0);\nRWTexture3D<unorm float4> LightBuffer : register(u1);\nTexture3D<unorm float4> DiffuseBuffer : register(t2);\nTexture3D<float4> NormalBuffer : register(t3);\nTexture3D<unorm float4> SurfaceBuffer : register(t4);\nbool IsInVoxelGrid(float3 Voxel)\n{\nreturn (Voxel.x >= 0.0 && Voxel.x < vxb_Size.x && Voxel.y >= 0.0 && Voxel.y < vxb_Size.y && Voxel.z >= 0.0 && Voxel.z < vxb_Size.z);\n}\nfloat GetAvg(float3 Value)\n{\nreturn (Value.x + Value.y + Value.z) / 3.0;\n}\nfloat3 GetVoxel(float3 Position)\n{\nfloat3 Voxel = clamp(Position - vxb_Center, -vxb_Scale, vxb_Scale) / vxb_Scale;\nreturn (float3(0.5, -0.5, 0.5) * Voxel + 0.5) * vxb_Size;\n}\nfloat3 GetVoxelToWorld(uint3 Position)\n{\nfloat3 Result = (float3)Position / vxb_Size;\nResult = (2.0 * Result - 1.0) * vxb_Scale - vxb_Center;\nreturn float3(Result.x, -Result.y, Result.z);\n}\nfloat4 GetDiffuse(uint3 Voxel)\n{\nreturn DiffuseBuffer.Load(int4((int3)Voxel.xyz, 0));\n}\nfloat4 GetNormal(uint3 Voxel)\n{\nreturn NormalBuffer.Load(int4((int3)Voxel.xyz, 0));\n}\nfloat4 GetSurface(uint3 Voxel)\n{\nreturn SurfaceBuffer.Load(int4((int3)Voxel.xyz, 0));\n}\nFragment GetFragmentWithDiffuse(float4 C0, uint3 Voxel)\n{\nint4 Coord = int4((int3)Voxel.xyz, 0);\nfloat4 C1 = NormalBuffer.Load(Coord);\nfloat4 C3 = SurfaceBuffer.Load(Coord);\nFragment Result;\nResult.Position = GetVoxelToWorld(Voxel);\nResult.Diffuse = C0.xyz;\nResult.Alpha = C0.w;\nResult.Normal = C1.xyz;\nResult.Material = C1.w;\nResult.Depth = 0.0;\nResult.Roughness = C3.x;\nResult.Metallic = C3.y;\nResult.Occlusion = C3.z;\nResult.Emission = C3.w;\nreturn Result;\n}\nFragment GetFragment(uint3 Voxel)\n{\nfloat4 C0 = DiffuseBuffer.Load(int4((int3)Voxel.xyz, 0));\nreturn GetFragmentWithDiffuse(C0, Voxel);\n}";
		callback(context, "std/channels/rvoxelizer.hlsl", std_channels_rvoxelizer_hlsl, sizeof(std_channels_rvoxelizer_hlsl));

		const unsigned char std_channels_stream_hlsl[] = "#include \"std/channels/geometry.hlsl\"\n#include \"std/objects/element.hlsl\"\nStructuredBuffer<Element> Elements : register(t8);";
		callback(context, "std/channels/stream.hlsl", std_channels_stream_hlsl, sizeof(std_channels_stream_hlsl));

		const unsigned char std_core_atmosphere_hlsl[] = "#pragma warning(disable: 4000)\nstruct Scatter\n{\nfloat Sun;\nfloat Planet;\nfloat Atmos;\nfloat3 Rlh;\nfloat3 Mie;\nfloat RlhHeight;\nfloat MieHeight;\nfloat MieG;\n};\nfloat2 GetRSI(float3 O, float3 D, float L)\n{\nfloat A = dot(D, D);\nfloat B = 2.0 * dot(D, O);\nfloat C = dot(O, O) - (L * L);\nfloat R = (B * B) - 4.0 * A * C;\n[branch] if (R < 0.0)\nreturn float2(1e5, -1e5);\nreturn float2((-B - sqrt(R)) / (2.0 * A), (-B + sqrt(R)) / (2.0 * A));\n}\nfloat3 GetAtmosphere(float2 TexCoord, matrix InvOffset, float3 O, float3 P, Scatter A)\n{\n#ifdef TARGET_D3D\nfloat4 V = float4(TexCoord.x * 2.0 - 1.0, 1.0 - TexCoord.y * 2.0, 1.0, 1.0);\n#else\nfloat4 V = float4(TexCoord.xy * 2.0 - 1.0, 1.0, 1.0);\n#endif\nV = mul(V, InvOffset);\nV = normalize(V / V.w);\nfloat2 Offset = GetRSI(O, V.xyz, A.Atmos);\n[branch] if (A.Sun <= 0.0 || Offset.x > Offset.y)\nreturn float3(0, 0, 0);\nOffset.y = min(Offset.y, GetRSI(O, V.xyz, A.Planet).x);\nfloat StepSize = (Offset.y - Offset.x) / float(10);\nfloat Time = 0.0;\nfloat3 TotalRlh = float3(0,0,0);\nfloat3 TotalMie = float3(0,0,0);\nfloat OdRlh = 0.0;\nfloat OdMie = 0.0;\nfloat MU = dot(V.xyz, P);\nfloat MU2 = MU * MU;\nfloat MieG2 = A.MieG * A.MieG;\nfloat ResRlh = 3.0 / (10 * 3.141592) * (1.0 + MU2);\nfloat ResMie = 3.0 / (8 * 3.141592) * ((1.0 - MieG2) * (MU2 + 1.0)) / (pow(abs(1.0 + MieG2 - 2.0 * MU * A.MieG), 1.5) * (2.0 + MieG2));\n[unroll] for (int i = 0; i < 10; i++)\n{\nfloat3 Next = O + V.xyz * (Time + StepSize * 0.5);\nfloat Height = length(Next) - A.Planet;\nfloat OdStepRlh = exp(-Height / A.RlhHeight) * StepSize;\nfloat OdStepMie = exp(-Height / A.MieHeight) * StepSize;\nOdRlh += OdStepRlh;\nOdMie += OdStepMie;\nfloat SubstepSize = GetRSI(Next, P, A.Atmos).y / 8;\nfloat SubTime = 0.0;\nfloat SubOdRlh = 0.0;\nfloat SubOdMie = 0.0;\n[unroll] for (int j = 0; j < 8; j++)\n{\nfloat3 SubNext = Next + P * (SubTime + SubstepSize * 0.5);\nfloat SubHeight = length(SubNext) - A.Planet;\nSubOdRlh += exp(-SubHeight / A.RlhHeight) * SubstepSize;\nSubOdMie += exp(-SubHeight / A.MieHeight) * SubstepSize;\nSubTime += SubstepSize;\n}\nfloat3 R = exp(-(A.Mie * (OdMie + SubOdMie) + A.Rlh * (OdRlh + SubOdRlh)));\nTotalRlh += OdStepRlh * R;\nTotalMie += OdStepMie * R;\nTime += StepSize;\n}\nreturn A.Sun * (ResRlh * A.Rlh * TotalRlh + ResMie * A.Mie * TotalMie);\n}";
		callback(context, "std/core/atmosphere.hlsl", std_core_atmosphere_hlsl, sizeof(std_core_atmosphere_hlsl));

		const unsigned char std_core_compress_hlsl[] = "float2 EncodeSC(float3 N)\n{\nreturn (float2(atan2(N.y, N.x) / 3.1415926536, N.z) + 1.0) * 0.5;\n}\nfloat3 DecodeSC(float2 N)\n{\nfloat2 V = N * 2.0 - 1.0, C1;\nsincos(V.x * 3.1415926536, C1.x, C1.y);\nfloat2 C2 = float2(sqrt(1.0 - V.y * V.y), V.y);\nreturn float3(C1.y * C2.x, C1.x * C2.x, C2.y);\n}\nfloat2 EncodeSM(float3 N)\n{\nfloat2 R = normalize(N.xy) * (sqrt(-N.z * 0.5 + 0.5));\nreturn R * 0.5 + 0.5;\n}\nfloat3 DecodeSM(float2 N)\n{\nfloat4 R = float4(N * 2, 0, 0) + float4(-1, -1, 1, -1);\nfloat L = dot(R.xyz, -R.xyw);\nR.xy *= sqrt(L);\nR.z = L;\nreturn R.xyz * 2 + float3(0, 0, -1);\n}";
		callback(context, "std/core/compress.hlsl", std_core_compress_hlsl, sizeof(std_core_compress_hlsl));

		const unsigned char std_core_lighting_hlsl[] = "float GetRangeAttenuation(float3 L, float C1, float C2, float Distance)\n{ \nfloat F = length(L);\nfloat D = max(F - Distance, 0.0);\nfloat I = D / Distance + 1.0;\nreturn max(((1.0 / (I * I)) - C1) / (1.0 - C2), 0.0);\n}\nfloat GetConeAttenuation(float3 L, float3 LN, float C1, float C2, float Distance, float3 Axis, float Angle)\n{\nreturn 3.0 * GetRangeAttenuation(L, C1, C2, Distance) * max(1.0 - (1.0 - dot(-LN, Axis)) * 1.0 / (1.0 - Angle), 0.0);\n}\nfloat GetSubsurface(float3 N, float3 V, float3 Origin, float3 Scatter)\n{\nreturn saturate(dot(-N, Origin)) * pow(saturate(dot(V, -normalize(Origin + N * Scatter.x))), Scatter.y) * Scatter.z;\n}\nfloat3 GetFresnelSchlick(float NdotV, float3 Metallic)\n{\nreturn Metallic + (1.0 - Metallic) * pow(1.0 - NdotV, 5.0);\n}\nfloat3 GetBaseReflectivity(float3 Albedo, float3 Metallic)\n{\nreturn lerp(float3(0.04, 0.04, 0.04), Albedo, Metallic);\n}\nfloat GetDistributionGGX(float NdotH, float Roughness)\n{\nfloat A = Roughness * Roughness;\nfloat A2 = A * A;\nfloat Denom = (NdotH * NdotH * (A2 - 1.0) + 1.0);\nDenom = 3.141592 * Denom * Denom;\nreturn A2 / max(Denom, 0.00001);\n}\nfloat GetGeometrySmith(float NdotV, float NdotL, float Roughness)\n{\nfloat R = (Roughness + 1.0);\nfloat K = (R * R) / 8.0;\nfloat GGX1 = NdotV / (NdotV * (1.0 - K) + K);\nfloat GGX2 = NdotL / (NdotL * (1.0 - K) + K);\nreturn GGX1 * GGX2;\n}\nfloat3 GetCookTorranceBRDF(float3 N, float3 V, float3 L, float3 Albedo, float3 Metallic, float Roughness)\n{\nfloat3 H = normalize(V + L);\nfloat NdotV = max(dot(N, V), 0.00001);\nfloat NdotL = max(dot(N, L), 0.00001);\nfloat HdotV = max(dot(H, V), 0.0);\nfloat NdotH = max(dot(N, H), 0.0);\nfloat D = GetDistributionGGX(NdotH, Roughness);\nfloat G = GetGeometrySmith(NdotV, NdotL, Roughness);\nfloat3 M = GetBaseReflectivity(Albedo, Metallic);\nfloat3 F = GetFresnelSchlick(HdotV, M);\nfloat3 R = D * G * F;\nfloat3 K = 1.0 - F;\nK *= 1.0 - M;\nR /= 4.0 * NdotV * NdotL;\nreturn (K * Albedo / 3.141592 + R) * NdotL;\n}\nfloat3 GetSpecularBRDF(float3 N, float3 V, float3 L, float3 Albedo, float3 Metallic, float Roughness)\n{\nfloat3 H = normalize(V + L);\nfloat NdotV = max(dot(N, V), 0.00001);\nfloat NdotL = max(dot(N, L), 0.00001);\nfloat HdotV = max(dot(H, V), 0.0);\nfloat NdotH = max(dot(N, H), 0.0);\nfloat D = GetDistributionGGX(NdotH, Roughness);\nfloat G = GetGeometrySmith(NdotV, NdotL, Roughness);\nfloat3 M = GetBaseReflectivity(0.0, Metallic * Albedo);\nfloat3 F = GetFresnelSchlick(HdotV, M);\nfloat3 R = D * G * F;\nR /= 4.0 * NdotV * NdotL;\nreturn R * NdotL;\n}";
		callback(context, "std/core/lighting.hlsl", std_core_lighting_hlsl, sizeof(std_core_lighting_hlsl));

		const unsigned char std_core_material_hlsl[] = "#include \"std/objects/fragment.hlsl\"\n#include \"std/objects/material.hlsl\"\nfloat GetRoughnessMip(Fragment Frag, Material Mat, in float MaxLevels)\n{\nreturn MaxLevels * (Mat.Roughness.x + Frag.Roughness * Mat.Roughness.y);\n}\nfloat GetRoughness(Fragment Frag, Material Mat)\n{\nreturn Mat.Roughness.x + Frag.Roughness * Mat.Roughness.y;\n}\nfloat3 GetMetallic(Fragment Frag, Material Mat)\n{\nreturn Mat.Metallic.xyz + Frag.Metallic * Mat.Metallic.w;\n}\nfloat GetOcclusion(Fragment Frag, Material Mat)\n{\nreturn Mat.Occlusion.x + Frag.Occlusion * Mat.Occlusion.y;\n}\nfloat3 GetEmission(Fragment Frag, Material Mat)\n{\nreturn (Mat.Emission.xyz + Frag.Emission) * Mat.Emission.w;\n}\nfloat3 GetSurface(Fragment Frag, Material Mat)\n{\nreturn Mat.Emission.xyz + Frag.Emission;\n}";
		callback(context, "std/core/material.hlsl", std_core_material_hlsl, sizeof(std_core_material_hlsl));

		const unsigned char std_core_multisample_hlsl[] = "static const float3 SampleDisk[64] =\n{\nfloat3(-1, -1, 1),\nfloat3(-0.7142857142857143, -1, 0.7142857142857143),\nfloat3(-0.42857142857142855, -1, 0.42857142857142855),\nfloat3(-0.14285714285714285, -1, 0.14285714285714285),\nfloat3(0.14285714285714285, -1, -0.14285714285714285),\nfloat3(0.42857142857142855, -1, -0.42857142857142855),\nfloat3(0.7142857142857143, -1, -0.7142857142857143),\nfloat3(1, -1, -1),\nfloat3(-1, -0.7142857142857143, 0.7142857142857143),\nfloat3(-0.7142857142857143, -0.7142857142857143, 0.5102040816326531),\nfloat3(-0.42857142857142855, -0.7142857142857143, 0.30612244897959184),\nfloat3(-0.14285714285714285, -0.7142857142857143, 0.10204081632653061),\nfloat3(0.14285714285714285, -0.7142857142857143, -0.10204081632653061),\nfloat3(0.42857142857142855, -0.7142857142857143, -0.30612244897959184),\nfloat3(0.7142857142857143, -0.7142857142857143, -0.5102040816326531),\nfloat3(1, -0.7142857142857143, -0.7142857142857143),\nfloat3(-1, -0.42857142857142855, 0.42857142857142855),\nfloat3(-0.7142857142857143, -0.42857142857142855, 0.30612244897959184),\nfloat3(-0.42857142857142855, -0.42857142857142855, 0.18367346938775508),\nfloat3(-0.14285714285714285, -0.42857142857142855, 0.06122448979591836),\nfloat3(0.14285714285714285, -0.42857142857142855, -0.06122448979591836),\nfloat3(0.42857142857142855, -0.42857142857142855, -0.18367346938775508),\nfloat3(0.7142857142857143, -0.42857142857142855, -0.30612244897959184),\nfloat3(1, -0.42857142857142855, -0.42857142857142855),\nfloat3(-1, -0.14285714285714285, 0.14285714285714285),\nfloat3(-0.7142857142857143, -0.14285714285714285, 0.10204081632653061),\nfloat3(-0.42857142857142855, -0.14285714285714285, 0.06122448979591836),\nfloat3(-0.14285714285714285, -0.14285714285714285, 0.02040816326530612),\nfloat3(0.14285714285714285, -0.14285714285714285, -0.02040816326530612),\nfloat3(0.42857142857142855, -0.14285714285714285, -0.06122448979591836),\nfloat3(0.7142857142857143, -0.14285714285714285, -0.10204081632653061),\nfloat3(1, -0.14285714285714285, -0.14285714285714285),\nfloat3(-1, 0.14285714285714285, -0.14285714285714285),\nfloat3(-0.7142857142857143, 0.14285714285714285, -0.10204081632653061),\nfloat3(-0.42857142857142855, 0.14285714285714285, -0.06122448979591836),\nfloat3(-0.14285714285714285, 0.14285714285714285, -0.02040816326530612),\nfloat3(0.14285714285714285, 0.14285714285714285, 0.02040816326530612),\nfloat3(0.42857142857142855, 0.14285714285714285, 0.06122448979591836),\nfloat3(0.7142857142857143, 0.14285714285714285, 0.10204081632653061),\nfloat3(1, 0.14285714285714285, 0.14285714285714285),\nfloat3(-1, 0.42857142857142855, -0.42857142857142855),\nfloat3(-0.7142857142857143, 0.42857142857142855, -0.30612244897959184),\nfloat3(-0.42857142857142855, 0.42857142857142855, -0.18367346938775508),\nfloat3(-0.14285714285714285, 0.42857142857142855, -0.06122448979591836),\nfloat3(0.14285714285714285, 0.42857142857142855, 0.06122448979591836),\nfloat3(0.42857142857142855, 0.42857142857142855, 0.18367346938775508),\nfloat3(0.7142857142857143, 0.42857142857142855, 0.30612244897959184),\nfloat3(1, 0.42857142857142855, 0.42857142857142855),\nfloat3(-1, 0.7142857142857143, -0.7142857142857143),\nfloat3(-0.7142857142857143, 0.7142857142857143, -0.5102040816326531),\nfloat3(-0.42857142857142855, 0.7142857142857143, -0.30612244897959184),\nfloat3(-0.14285714285714285, 0.7142857142857143, -0.10204081632653061),\nfloat3(0.14285714285714285, 0.7142857142857143, 0.10204081632653061),\nfloat3(0.42857142857142855, 0.7142857142857143, 0.30612244897959184),\nfloat3(0.7142857142857143, 0.7142857142857143, 0.5102040816326531),\nfloat3(1, 0.7142857142857143, 0.7142857142857143),\nfloat3(-1, 1, -1),\nfloat3(-0.7142857142857143, 1, -0.7142857142857143),\nfloat3(-0.42857142857142855, 1, -0.42857142857142855),\nfloat3(-0.14285714285714285, 1, -0.14285714285714285),\nfloat3(0.14285714285714285, 1, 0.14285714285714285),\nfloat3(0.42857142857142855, 1, 0.42857142857142855),\nfloat3(0.7142857142857143, 1, 0.7142857142857143),\nfloat3(1, 1, 1)\n};";
		callback(context, "std/core/multisample.hlsl", std_core_multisample_hlsl, sizeof(std_core_multisample_hlsl));

		const unsigned char std_core_position_hlsl[] = "#include \"std/buffers/viewer.hlsl\"\nfloat2 GetTexCoord(float4 UV)\n{\n#ifdef TARGET_D3D\nreturn float2(0.5f + 0.5f * UV.x / UV.w, 0.5f - 0.5f * UV.y / UV.w);\n#else\nreturn float2(0.5f + 0.5f * UV.x / UV.w, 0.5f + 0.5f * UV.y / UV.w);\n#endif\n}\nfloat3 GetPosition(float2 TexCoord, float Depth)\n{\n#ifdef TARGET_D3D\nfloat4 Position = float4(TexCoord.x * 2.0 - 1.0, 1.0 - TexCoord.y * 2.0, Depth, 1.0);\n#else\nfloat4 Position = float4(TexCoord * 2.0 - 1.0, Depth, 1.0);\n#endif\nPosition = mul(Position, vb_InvViewProj);\nreturn Position.xyz / Position.w;\n}\nfloat3 GetPositionUV(float3 Position)\n{\nfloat4 Coord = mul(float4(Position, 1.0), vb_ViewProj);\n#ifdef TARGET_D3D\nCoord.xy = float2(0.5, 0.5) + float2(0.5, -0.5) * Coord.xy / Coord.w;\n#else\nCoord.xy = float2(0.5, 0.5) + float2(0.5, 0.5) * Coord.xy / Coord.w;\n#endif\nCoord.z /= Coord.w;\nreturn Coord.xyz;\n}";
		callback(context, "std/core/position.hlsl", std_core_position_hlsl, sizeof(std_core_position_hlsl));

		const unsigned char std_core_pow_hlsl[] = "float Pow4(float Value)\n{\nreturn Value * Value * Value * Value;\n}";
		callback(context, "std/core/pow.hlsl", std_core_pow_hlsl, sizeof(std_core_pow_hlsl));

		const unsigned char std_core_random_hlsl[] = "/*\n// @Gaussian is generated using following algorithm (js):\nfunction get_distribution(circles = 3, repeats = 11, samples = 4, radius = 0.5, angle = 90)\n{\nlet points = [], rotation = 0.0;\nfor (let k = 0; k < repeats; k++)\n{\nfor (let i = 0; i < circles; i++)\n{\nfor (let j = 0; j < samples; j++)\n{\nlet theta = j * 2 * Math.PI / samples;\ntheta += rotation;\nlet x = Math.cos(theta), y = Math.sin(theta);\nx += x * radius * i;\ny += y * radius * i;\npoints.push([x, y]);\n}\nrotation += (angle * Math.PI / 180) / repeats;\n}\n}\nlet floats = '';\nfor (let i = 0; i < points.length; i++)\nfloats += `\tfloat2(${points[i][0]}, ${points[i][1]}),\n`;\nreturn floats.substring(0, floats.length - 2);\n}\n*/\nstatic const float2 Gaussian[132] =\n{\nfloat2(1, 0),\nfloat2(6.123233995736766e-17, 1),\nfloat2(-1, 1.2246467991473532e-16),\nfloat2(-1.8369701987210297e-16, -1),\nfloat2(1.484732162821399, 0.2134722574099277),\nfloat2(-0.2134722574099275, 1.4847321628213992),\nfloat2(-1.4847321628213992, -0.21347225740992737),\nfloat2(0.2134722574099273, -1.4847321628213992),\nfloat2(1.9189859472289947, 0.5634651136828593),\nfloat2(-0.5634651136828593, 1.9189859472289947),\nfloat2(-1.918985947228995, -0.5634651136828588),\nfloat2(0.5634651136828587, -1.918985947228995),\nfloat2(0.9096319953545184, 0.4154150130018864),\nfloat2(-0.4154150130018863, 0.9096319953545184),\nfloat2(-0.9096319953545186, -0.4154150130018861),\nfloat2(0.41541501300188605, -0.9096319953545186),\nfloat2(1.261880299246772, 0.8109612261833963),\nfloat2(-0.8109612261833965, 1.2618802992467717),\nfloat2(-1.261880299246772, -0.8109612261833963),\nfloat2(0.8109612261833956, -1.2618802992467721),\nfloat2(1.5114991487085165, 1.3097214678905702),\nfloat2(-1.30972146789057, 1.5114991487085165),\nfloat2(-1.5114991487085168, -1.30972146789057),\nfloat2(1.3097214678905706, -1.5114991487085163),\nfloat2(0.654860733945285, 0.7557495743542583),\nfloat2(-0.7557495743542582, 0.6548607339452852),\nfloat2(-0.6548607339452852, -0.7557495743542582),\nfloat2(0.7557495743542584, -0.6548607339452849),\nfloat2(0.8109612261833963, 1.261880299246772),\nfloat2(-1.261880299246772, 0.8109612261833962),\nfloat2(-0.8109612261833962, -1.261880299246772),\nfloat2(1.261880299246772, -0.8109612261833962),\nfloat2(0.8308300260037729, 1.8192639907090367),\nfloat2(-1.8192639907090369, 0.8308300260037726),\nfloat2(-0.8308300260037728, -1.8192639907090369),\nfloat2(1.8192639907090367, -0.8308300260037729),\nfloat2(0.2817325568414298, 0.9594929736144974),\nfloat2(-0.9594929736144974, 0.28173255684142967),\nfloat2(-0.2817325568414297, -0.9594929736144974),\nfloat2(0.9594929736144974, -0.2817325568414298),\nfloat2(0.213472257409928, 1.484732162821399),\nfloat2(-1.484732162821399, 0.21347225740992776),\nfloat2(-0.21347225740992784, -1.484732162821399),\nfloat2(1.484732162821399, -0.21347225740992798),\nfloat2(5.66553889764798e-16, 2),\nfloat2(-2, 2.4492935982947064e-16),\nfloat2(-3.6739403974420594e-16, -2),\nfloat2(2, -4.898587196589413e-16),\nfloat2(-0.14231483827328478, 0.9898214418809328),\nfloat2(-0.9898214418809328, -0.14231483827328492),\nfloat2(0.14231483827328487, -0.9898214418809328),\nfloat2(0.9898214418809328, 0.1423148382732848),\nfloat2(-0.4225988352621439, 1.4392394604217462),\nfloat2(-1.4392394604217462, -0.4225988352621441),\nfloat2(0.42259883526214403, -1.4392394604217462),\nfloat2(1.4392394604217462, 0.4225988352621439),\nfloat2(-0.8308300260037719, 1.819263990709037),\nfloat2(-1.819263990709037, -0.8308300260037722),\nfloat2(0.8308300260037721, -1.819263990709037),\nfloat2(1.819263990709037, 0.830830026003772),\nfloat2(-0.5406408174555972, 0.8412535328311814),\nfloat2(-0.8412535328311814, -0.5406408174555972),\nfloat2(0.5406408174555971, -0.8412535328311814),\nfloat2(0.8412535328311815, 0.5406408174555971),\nfloat2(-0.9822911009179269, 1.133624361531388),\nfloat2(-1.133624361531388, -0.9822911009179269),\nfloat2(0.9822911009179268, -1.1336243615313881),\nfloat2(1.1336243615313881, 0.9822911009179268),\nfloat2(-1.5114991487085159, 1.309721467890571),\nfloat2(-1.309721467890571, -1.5114991487085156),\nfloat2(1.5114991487085156, -1.309721467890571),\nfloat2(1.3097214678905713, 1.5114991487085156),\nfloat2(-0.8412535328311808, 0.5406408174555981),\nfloat2(-0.5406408174555982, -0.8412535328311808),\nfloat2(0.8412535328311808, -0.5406408174555982),\nfloat2(0.5406408174555983, 0.8412535328311808),\nfloat2(-1.3644479930317772, 0.6231225195028307),\nfloat2(-0.6231225195028307, -1.364447993031777),\nfloat2(1.364447993031777, -0.6231225195028308),\nfloat2(0.6231225195028309, 1.364447993031777),\nfloat2(-1.9189859472289943, 0.563465113682861),\nfloat2(-0.5634651136828611, -1.9189859472289943),\nfloat2(1.9189859472289943, -0.5634651136828612),\nfloat2(0.5634651136828613, 1.9189859472289943),\nfloat2(-0.9898214418809326, 0.14231483827328606),\nfloat2(-0.14231483827328612, -0.9898214418809326),\nfloat2(0.9898214418809326, -0.14231483827328617),\nfloat2(0.14231483827328623, 0.9898214418809326),\nfloat2(-1.5, 1.515964649422291e-15),\nfloat2(-1.6078131593583423e-15, -1.5),\nfloat2(1.5, -1.6996616692943939e-15),\nfloat2(1.7915101792304454e-15, 1.5),\nfloat2(-1.9796428837618658, -0.2846296765465681),\nfloat2(0.284629676546568, -1.9796428837618658),\nfloat2(1.9796428837618658, 0.28462967654656784),\nfloat2(-0.28462967654656773, 1.9796428837618658),\nfloat2(-0.9594929736144977, -0.28173255684142856),\nfloat2(0.2817325568414285, -0.9594929736144977),\nfloat2(0.9594929736144978, 0.28173255684142845),\nfloat2(-0.2817325568414292, 0.9594929736144975),\nfloat2(-1.3644479930317783, -0.6231225195028279),\nfloat2(0.6231225195028278, -1.3644479930317783),\nfloat2(1.3644479930317785, 0.6231225195028277),\nfloat2(-0.6231225195028276, 1.3644479930317785),\nfloat2(-1.6825070656623637, -1.081281634911193),\nfloat2(1.081281634911193, -1.682507065662364),\nfloat2(1.682507065662364, 1.0812816349111927),\nfloat2(-1.0812816349111911, 1.6825070656623649),\nfloat2(-0.7557495743542593, -0.654860733945284),\nfloat2(0.6548607339452839, -0.7557495743542593),\nfloat2(0.7557495743542593, 0.6548607339452839),\nfloat2(-0.6548607339452839, 0.7557495743542594),\nfloat2(-0.9822911009179294, -1.133624361531386),\nfloat2(1.133624361531386, -0.9822911009179294),\nfloat2(0.9822911009179295, 1.1336243615313857),\nfloat2(-1.1336243615313866, 0.9822911009179285),\nfloat2(-1.0812816349111978, -1.6825070656623606),\nfloat2(1.6825070656623606, -1.081281634911198),\nfloat2(1.081281634911198, 1.6825070656623604),\nfloat2(-1.6825070656623604, 1.0812816349111982),\nfloat2(-0.415415013001888, -0.9096319953545177),\nfloat2(0.9096319953545177, -0.41541501300188804),\nfloat2(0.4154150130018881, 0.9096319953545177),\nfloat2(-0.9096319953545172, 0.41541501300188893),\nfloat2(-0.4225988352621471, -1.4392394604217453),\nfloat2(1.4392394604217453, -0.42259883526214714),\nfloat2(0.42259883526214725, 1.4392394604217453),\nfloat2(-1.4392394604217453, 0.4225988352621474),\nfloat2(-0.284629676546574, -1.979642883761865),\nfloat2(1.979642883761865, -0.2846296765465741),\nfloat2(0.28462967654657423, 1.979642883761865),\nfloat2(-1.9796428837618651, 0.2846296765465726)\n};\nfloat RandomFloat(float3 Value)\n{\nreturn sin(dot(sin(Value), float3(12.9898, 78.233, 37.719))) * 143758.5453;\n}\nfloat RandomFloatXY(float X, float Y)\n{\nreturn frac(sin(dot(float2(X, Y), float2(12.9898f, 78.233f))) * 43758.5453f);\n}\nfloat2 RandomFloat2(float2 Value)\n{\nfloat X = saturate(frac(sin(dot(Value, float2(12.9898f, 78.233f))) * 43758.5453f)) * 2.0 - 1.0;\nfloat Y = saturate(frac(sin(dot(Value, float2(12.9898f, 78.233f) * 2.0)) * 43758.5453f)) * 2.0 - 1.0;\nreturn float2(X, Y);\n}\nfloat3 RandomFloat3(float2 Value)\n{\nfloat X = saturate(frac(sin(dot(Value, float2(12.9898f, 78.233f))) * 43758.5453f)) * 2.0 - 1.0;\nfloat Y = saturate(frac(sin(dot(Value, float2(12.9898f, 78.233f) * 2.0)) * 43758.5453f)) * 2.0 - 1.0;\nfloat Z = saturate(frac(sin(dot(Value.yx, float2(12.9898f, 78.233f) * 4.0)) * 43758.5453f)) * 2.0 - 1.0;\nreturn float3(X, Y, Z);\n}\nfloat Hash12(float2 V)\n{\nV = frac(V * float2(5.3987, 5.4421));\nV += dot(V.yx, V.xy + float2(21.5351, 14.3137));\nreturn frac(V.x * V.y * 95.4307);\n}";
		callback(context, "std/core/random.hlsl", std_core_random_hlsl, sizeof(std_core_random_hlsl));

		const unsigned char std_core_raymarching_hlsl[] = "#include \"std/channels/effect.hlsl\"\n#include \"std/core/position.hlsl\"\nfloat Rayprefix(float3 Eye, float3 Direction)\n{\nreturn 1.0 - smoothstep(0.1, 0.75, dot(-Eye, Direction));\n}\nfloat Raypostfix(float2 TexCoord, float3 Direction)\n{\nfloat2 Size = smoothstep(0.1, 0.2, TexCoord) * (1.0 - smoothstep(0.9, 1.0, TexCoord));\nreturn Size.x * Size.y * smoothstep(-0.05, 0.0, dot(GetNormal(TexCoord), -Direction));\n}\nfloat Rayreduce(float3 Position, float3 TexCoord, float Power)\n{\nfloat Size = length(GetPosition(TexCoord.xy, TexCoord.z) - Position) * Power;\nreturn 1.0 / (1.0 + 6.0 * Size * Size);\n}\nfloat3 Raysearch(float3 Ray1, float3 Ray2)\n{\nconst float Steps = 12.0;\nconst float Bias = 0.00005;\nfloat3 Low = Ray1;\nfloat3 High = Ray2;\nfloat3 Result = 0.0;\n[unroll] for (float i = 0; i < Steps; i++)\n{\nResult = lerp(Low, High, 0.5);\nfloat Depth = GetDepth(Result.xy);\n[branch] if (Result.z > Depth + Bias)\nHigh = Result;\nelse\nLow = Result;\n}\nreturn Result;\n}\nfloat3 Raymarch(float3 Position, float3 Direction, float Iterations, float Step)\n{\nconst float Bias = 0.00005;\nfloat3 Ray = Direction * Step;\nfloat3 Sample = 0.0;\n[loop] for (float i = 0; i < Iterations; i++)\n{\nfloat3 Next = GetPositionUV(Position + Ray * i);\n[branch] if (!IsInPixelGrid(Next.xy))\nbreak;\nfloat Depth = GetDepth(Next.xy);\n[branch] if (Next.z >= Depth + Bias)\nreturn Raysearch(Sample, Next);\nSample = Next;\n}\nreturn -1.0;\n}";
		callback(context, "std/core/raymarching.hlsl", std_core_raymarching_hlsl, sizeof(std_core_raymarching_hlsl));

		const unsigned char std_core_raytracing_hlsl[] = "#include \"std/channels/raytracer.hlsl\"\nfloat3 Rayproject(float3 Normal)\n{\nconst float3 Base = float3(0.99146, 0.11664, 0.05832);\nconst float3 Edge = float3(0.0, 1.0, 0.0);\nreturn abs(dot(Normal, Base)) > 0.99999 ? cross(Normal, Edge) : cross(Normal, Base);\n}\nfloat3 RaymarchSpecular(float3 Position, float3 Normal, float3 Direction, float MaxDistance, float Reflectivity)\n{\nconst float3 Intensity = 1.0 + Reflectivity;\nconst float3 Offset = vxb_Distance / vxb_Scale;\nconst float3 Step = 1.0 / vxb_Scale;\nfloat3 Distance = Offset;\nfloat4 Result = 0.0;\nfloat Count = 0.0;\nPosition += Offset * Normal;\nwhile (Distance.x < MaxDistance && Result.w < 1.0)\n{\nfloat3 Voxel = GetVoxel(Position + Direction * Distance);\n[branch] if (!IsInVoxelGrid(Voxel) || Count++ >= vxb_MaxSteps)\nbreak;\nfloat Radius = 0.1 * Reflectivity * log2(1.0 + GetAvg(Distance * vxb_Scale));\nfloat4 Diffuse = GetLight(Voxel, min(Radius * vxb_Mips, vxb_Mips));\nfloat Volume = 1.0 - Result.w;\nResult.xyz += Intensity * Diffuse.xyz * Diffuse.w * Volume;\nResult.w += Diffuse.a * Volume;\nDistance += Step * (1.0f + 0.125f * Radius);\n}\nreturn Result.xyz;\n}\nfloat3 RaymarchRadiance(float3 Origin, float3 Direction, out float Occlusion)\n{\nconst float3 Step = vxb_Distance / vxb_Scale;\nconst float Offset = 1.154;\nconst float Depth = 0.03;\nfloat3 Distance = Step * 0.5;\nfloat4 Result = 0.0;\nfloat Count = 0.0;\nwhile (Distance.x < vxb_Scale.x && Result.w < 1.0)\n{\nfloat3 Voxel = GetVoxel(Origin + Direction * Distance);\n[branch] if (!IsInVoxelGrid(Voxel) || Count++ >= vxb_MaxSteps)\nbreak;\nfloat3 Radius = max(Offset * Distance, Step);\nfloat Roughness = log2(GetAvg(Radius * vxb_Scale));\nfloat4 Diffuse = GetLight(Voxel, min(Roughness, vxb_Mips));\nResult += Diffuse * (1.0 - Result.w);\nDistance += Radius * vxb_Step / max(1.0, Roughness);\nOcclusion += Diffuse.w / (1.0 + Depth * GetAvg(Radius));\n}\nreturn Result.xyz * Result.w;\n}\nfloat3 GetSpecular(float3 Position, float3 Normal, float3 Eye, float MaxDistance, float3 Metallic, float Roughness)\n{\nfloat3 Direction = reflect(Eye, Normal);\nreturn RaymarchSpecular(Position, Normal, Direction, MaxDistance, Roughness) * Metallic;\n}\nfloat3 GetRefraction(float3 Position, float3 Normal, float3 Eye, float MaxDistance, float3 Metallic, float Roughness, float Refraction, float Transparency)\n{\nfloat3 Direction = refract(Eye, Normal, 1.0 / Refraction);\nfloat3 Diffuse = lerp(Metallic, 0.5 * (Metallic + 1.0), Transparency);\nreturn RaymarchSpecular(Position, Normal, Direction, MaxDistance, Roughness) * Diffuse;\n}\nfloat3 GetRadiance(float3 Position, float3 Normal, float3 Metallic, out float Shadow)\n{\nconst float3 Origin = Position + Normal * vxb_Margin / vxb_Scale;\nconst float3 Ortho1 = normalize(Rayproject(Normal));\nconst float3 Ortho2 = normalize(cross(Ortho1, Normal));\nconst float3 Corner1 = 0.5f * (Ortho1 + Ortho2);\nconst float3 Corner2 = 0.5f * (Ortho1 - Ortho2);\nfloat Occlusion = 0.0;\nfloat3 Result = 0.0;\nResult += RaymarchRadiance(Origin + vxb_Offset * Normal, Normal, Occlusion);\nResult += RaymarchRadiance(Origin + vxb_Offset * Ortho1, lerp(Normal, Ortho1, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin - vxb_Offset * Ortho1, lerp(Normal, -Ortho1, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin + vxb_Offset * Ortho2, lerp(Normal, Ortho2, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin - vxb_Offset * Ortho2, lerp(Normal, -Ortho2, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin + vxb_Offset * Corner1, lerp(Normal, Corner1, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin - vxb_Offset * Corner1, lerp(Normal, -Corner1, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin + vxb_Offset * Corner2, lerp(Normal, Corner2, vxb_Angle), Occlusion);\nResult += RaymarchRadiance(Origin - vxb_Offset * Corner2, lerp(Normal, -Corner2, vxb_Angle), Occlusion);\nShadow = saturate(1.0 - Occlusion * vxb_Occlusion);\nreturn Result;\n}";
		callback(context, "std/core/raytracing.hlsl", std_core_raytracing_hlsl, sizeof(std_core_raytracing_hlsl));

		const unsigned char std_core_sampler_hlsl[] = "\nfloat4 GetSample3(TextureCube Texture, float3 TexCoord)\n{\nreturn Texture.Sample(Sampler, TexCoord);\n}\nfloat4 GetSample3Level(TextureCube Texture, float3 TexCoord, float Level)\n{\nreturn Texture.SampleLevel(Sampler, TexCoord, Level);\n}";
		callback(context, "std/core/sampler.hlsl", std_core_sampler_hlsl, sizeof(std_core_sampler_hlsl));

		const unsigned char std_layouts_element_hlsl[] = "struct VInput\n{\nuint Position : SV_VERTEXID;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat4 Color : TEXCOORD0;\nfloat2 TexCoord : TEXCOORD1;\nfloat Scale : TEXCOORD2;\nfloat Rotation : TEXCOORD3;\n};\nstruct VOutputOpaque\n{\nfloat4 Position : SV_POSITION;\nfloat4 UV : TEXCOORD0;\nfloat4 Color : TEXCOORD1;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\nfloat2 TexCoord : TEXCOORD2;\nfloat Scale : TEXCOORD3;\nfloat Rotation : TEXCOORD4;\n};\nstruct VOutputCubic\n{\nfloat4 Position : SV_POSITION;\nfloat4 UV : TEXCOORD0;\nfloat2 TexCoord : TEXCOORD1;\nfloat Rotation : TEXCOORD2;\nfloat Scale : TEXCOORD3;\nfloat Alpha : TEXCOORD4;\nuint RenderTarget : SV_RenderTargetArrayIndex;\n};\nstruct VOutputLinear\n{\nfloat4 Position : SV_POSITION;\nfloat4 UV : TEXCOORD0;\nfloat2 TexCoord : TEXCOORD1;\nfloat Rotation : TEXCOORD2;\nfloat Scale : TEXCOORD3;\nfloat Alpha : TEXCOORD4;\n};";
		callback(context, "std/layouts/element.hlsl", std_layouts_element_hlsl, sizeof(std_layouts_element_hlsl));

		const unsigned char std_layouts_interface_hlsl[] = "struct VInput\n{\nfloat2 Position : POSITION;\nfloat4 Color : COLOR0;\nfloat2 TexCoord : TEXCOORD0;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\nfloat4 Color : COLOR0;\n};";
		callback(context, "std/layouts/interface.hlsl", std_layouts_interface_hlsl, sizeof(std_layouts_interface_hlsl));

		const unsigned char std_layouts_shape_hlsl[] = "struct VInput\n{\nfloat3 Position : POSITION;\nfloat2 TexCoord : TEXCOORD0;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat4 TexCoord : TEXCOORD0;\n};";
		callback(context, "std/layouts/shape.hlsl", std_layouts_shape_hlsl, sizeof(std_layouts_shape_hlsl));

		const unsigned char std_layouts_skin_hlsl[] = "struct VInput\n{\nfloat3 Position : POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\nfloat4 Index : JOINTBIAS0;\nfloat4 Bias : JOINTBIAS1;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\nfloat4 UV : TEXCOORD1;\nfloat3 Direction : TEXCOORD2;\n};\nstruct VOutputCubic\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\nuint RenderTarget : SV_RenderTargetArrayIndex;\n};\nstruct VOutputLinear\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\n};";
		callback(context, "std/layouts/skin.hlsl", std_layouts_skin_hlsl, sizeof(std_layouts_skin_hlsl));

		const unsigned char std_layouts_vertex_instance_hlsl[] = "struct VInput\n{\nfloat3 Position : POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\n matrix OB_Transform : OB_TRANSFORM;\n matrix OB_World : OB_WORLD;\n float2 OB_TexCoord : OB_TEXCOORD;\nfloat4 OB_Material : OB_MATERIAL;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\nfloat4 UV : TEXCOORD1;\nfloat3 Direction : TEXCOORD2;\n float OB_Diffuse : TEXCOORD3;\n float OB_Normal : TEXCOORD4;\n float OB_Height : TEXCOORD5;\n uint OB_MaterialId : TEXCOORD6;\n};\nstruct VOutputCubic\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\n float OB_Diffuse : TEXCOORD2;\n uint OB_MaterialId : TEXCOORD3;\nuint RenderTarget : SV_RenderTargetArrayIndex;\n};\nstruct VOutputLinear\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\n float OB_Diffuse : TEXCOORD2;\n uint OB_MaterialId : TEXCOORD3;\n};";
		callback(context, "std/layouts/vertex-instance.hlsl", std_layouts_vertex_instance_hlsl, sizeof(std_layouts_vertex_instance_hlsl));

		const unsigned char std_layouts_vertex_hlsl[] = "struct VInput\n{\nfloat3 Position : POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\n};\nstruct VOutput\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat3 Normal : NORMAL0;\nfloat3 Tangent : TANGENT0;\nfloat3 Bitangent : BINORMAL0;\nfloat4 UV : TEXCOORD1;\nfloat3 Direction : TEXCOORD2;\n};\nstruct VOutputCubic\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\nuint RenderTarget : SV_RenderTargetArrayIndex;\n};\nstruct VOutputLinear\n{\nfloat4 Position : SV_POSITION;\nfloat2 TexCoord : TEXCOORD0;\nfloat4 UV : TEXCOORD1;\n};";
		callback(context, "std/layouts/vertex.hlsl", std_layouts_vertex_hlsl, sizeof(std_layouts_vertex_hlsl));

		const unsigned char std_objects_element_hlsl[] = "struct Element\n{\nfloat3 Position;\nfloat Scale;\nfloat3 Velocity;\nfloat Rotation;\nfloat3 Padding;\nfloat Angular;\nfloat4 Color;\n};";
		callback(context, "std/objects/element.hlsl", std_objects_element_hlsl, sizeof(std_objects_element_hlsl));

		const unsigned char std_objects_fragment_hlsl[] = "struct Fragment\n{\nfloat3 Position;\nfloat3 Diffuse;\nfloat3 Normal;\nfloat Roughness;\nfloat Metallic;\nfloat Occlusion;\nfloat Emission;\nfloat Material;\nfloat Depth;\nfloat Alpha;\n};";
		callback(context, "std/objects/fragment.hlsl", std_objects_fragment_hlsl, sizeof(std_objects_fragment_hlsl));

		const unsigned char std_objects_gbuffer_hlsl[] = "struct GBuffer\n{\nfloat4 DiffuseBuffer : SV_TARGET0;\nfloat4 NormalBuffer : SV_TARGET1;\nfloat DepthBuffer : SV_TARGET2;\nfloat4 SurfaceBuffer : SV_TARGET3;\n};";
		callback(context, "std/objects/gbuffer.hlsl", std_objects_gbuffer_hlsl, sizeof(std_objects_gbuffer_hlsl));

		const unsigned char std_objects_material_hlsl[] = "struct Material\n{\nfloat4 Emission;\nfloat4 Metallic;\nfloat3 Diffuse;\nfloat Fresnel;\nfloat3 Scatter;\nfloat Transparency;\nfloat3 Padding;\nfloat Bias;\nfloat2 Roughness;\nfloat Refraction;\nfloat Environment;\nfloat2 Occlusion;\nfloat Radius;\nfloat Height;\n};";
		callback(context, "std/objects/material.hlsl", std_objects_material_hlsl, sizeof(std_objects_material_hlsl));
	}
}
#endif